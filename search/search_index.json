{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Network-wide ad blocking via your own Linux hardware The Pi-hole \u00ae is a DNS sinkhole that protects your devices from unwanted content, without installing any client-side software. Easy-to-install : our versatile installer walks you through the process, and takes less than ten minutes Resolute : content is blocked in non-browser locations , such as ad-laden mobile apps and smart TVs Responsive : seamlessly speeds up the feel of everyday browsing by caching DNS queries Lightweight : runs smoothly with minimal hardware and software requirements Robust : a command line interface that is quality assured for interoperability Insightful : a beautiful responsive Web Interface dashboard to view and control your Pi-hole Versatile : can optionally function as a DHCP server , ensuring all your devices are protected automatically Scalable : capable of handling hundreds of millions of queries when installed on server-grade hardware Modern : blocks ads over both IPv4 and IPv6 Free : open source software which helps ensure you are the sole person in control of your privacy Pi-hole is free, but powered by your support There are many reoccurring costs involved with maintaining free, open source, and privacy respecting software; expenses which our volunteer developers pitch in to cover out-of-pocket. This is just one example of how strongly we feel about our software, as well as the importance of keeping it maintained. Make no mistake: your support is absolutely vital to help keep us innovating! Donations Sending a donation using our links below is extremely helpful in offsetting a portion of our monthly expenses: Donate via PayPal Bitcoin : 3MDPzjXu2hjw5sGLJvKUi1uXbvQPzVrbpF Bitcoin Cash : qzqsz4aju2eecc6uhs7tus4vlwhhela24sdruf4qp5 Ethereum : 0x79d4e90A4a0C732819526c93e21A3F1356A2FAe1 Alternative support If you'd rather not donate ( which is okay! ), there are other ways you can help support us: Digital Ocean affiliate link UNIXstickers.com save $5 when you spend $9 using our affiliate link Pi-hole Swag Store affiliate link Amazon affiliate link Ho-ost save 50% with our affiliate link DNS Made Easy affiliate link Vultr affiliate link Spreading the word about our software, and how you have benefited from it Contributing via GitHub We welcome everyone to contribute to issue reports, suggest new features, and create pull requests. If you have something to add - anything from a typo through to a whole new feature, we're happy to check it out! Just make sure to fill out our template when submitting your request; the questions that it asks will help the volunteers quickly understand what you're aiming to achieve. You'll find that the install script and the debug script have an abundance of comments, which will help you better understand how Pi-hole works. They're also a valuable resource to those who want to learn how to write scripts or code a program! We encourage anyone who likes to tinker to read through it, and submit a pull request for us to review. Presentations about Pi-hole Word-of-mouth continues to help our project grow immensely, and so we are helping make this easier for people. If you are going to be presenting Pi-hole at a conference, meetup or even a school project, get in touch with us so we can hook you up with free swag to hand out to your audience! Getting in touch with us While we are primarily reachable on our Discourse User Forum , we can also be found on a variety of social media outlets. Please be sure to check the FAQ's before starting a new discussion, as we do not have the spare time to reply to every request for assistance. Frequently Asked Questions Pi-hole Wiki Feature Requests Discourse User Forum Reddit Gitter (Real-time chat) Twitter YouTube Facebook The Origin Of Pi-hole Pi-hole being a advertising-aware DNS /Web server , makes use of the following technologies: dnsmasq - a lightweight DNS and DHCP server curl - A command line tool for transferring data with URL syntax lighttpd - webserver designed and optimized for high performance php - a popular general-purpose web scripting language AdminLTE Dashboard - premium admin control panel based on Bootstrap 3.x While quite outdated at this point, this original blog post about Pi-hole goes into great detail about how Pi-hole was originally setup and how it works. Syntactically, it's no longer accurate, but the same basic principles and logic still apply to Pi-hole's current state. Pi-hole Projects The Big Blocklist Collection Docker Pi-hole container (x86 and ARM) Pi-Hole in the cloud Pie in the Sky-Hole [A Pi-Hole in the cloud for ad-blocking via DNS ] Pi-hole Enable/Disable Button Minibian Pi-hole CHiP-hole: Network-wide Ad-blocker Chrome Extension: Pi-Hole List Editor ( Source Code ) Splunk: Pi-hole Visualiser Adblocking with Pi-hole and Ubuntu 14.04 on VirtualBox Pi-hole stats in your Mac's menu bar Pi-hole unRAID Template Copernicus: Windows Tray Application Let your blink1 device blink when Pi-hole filters ads Pi-hole metrics exporter for Prometheus Magic Mirror with DNS Filtering Pi-hole Droid: Android client Windows DNS Swapper , see #1400 Pi-hole Visualizer Coverage Lifehacker: Turn A Raspberry Pi Into An Ad Blocker With A Single Command MakeUseOf: Adblock Everywhere: The Raspberry Pi-Hole Way Catchpoint: Ad-Blocking on Apple iOS9: Valuing the End User Experience Security Now Netcast: Pi-hole TekThing: Raspberry Pi-Hole Makes Ads Disappear! Foolish Tech Show Block Ads on All Home Devices for $53.18 Pi-Hole for Ubuntu 14.04 MacObserver Podcast 585 The Defrag Show: Endoscope USB Camera, The Final [HoloLens] Vote, Adblock Pi and more Adafruit: Pi-hole is a black hole for internet ads Digital Trends: 5 Fun, Easy Projects You Can Try With a $35 Raspberry Pi Adafruit: Raspberry Pi Quick Look at Pi Hole ad blocking server with Tony D Devacron: OrangePi Zero as an Ad-Block server with Pi-Hole Linux Pro: The Hole Truth CryptoAUSTRALIA: How We Tried 5 Privacy Focused Raspberry Pi Projects CryptoAUSTRALIA: Pi-hole Workshop Know How 355: Killing ads with a Raspberry Pi-Hole! Bloomberg: Inside the Brotherhood of the Ad Blockers","title":"Overview & Support"},{"location":"#pi-hole-is-free-but-powered-by-your-support","text":"There are many reoccurring costs involved with maintaining free, open source, and privacy respecting software; expenses which our volunteer developers pitch in to cover out-of-pocket. This is just one example of how strongly we feel about our software, as well as the importance of keeping it maintained. Make no mistake: your support is absolutely vital to help keep us innovating!","title":"Pi-hole is free, but powered by your support"},{"location":"#donations","text":"Sending a donation using our links below is extremely helpful in offsetting a portion of our monthly expenses: Donate via PayPal Bitcoin : 3MDPzjXu2hjw5sGLJvKUi1uXbvQPzVrbpF Bitcoin Cash : qzqsz4aju2eecc6uhs7tus4vlwhhela24sdruf4qp5 Ethereum : 0x79d4e90A4a0C732819526c93e21A3F1356A2FAe1","title":"Donations"},{"location":"#alternative-support","text":"If you'd rather not donate ( which is okay! ), there are other ways you can help support us: Digital Ocean affiliate link UNIXstickers.com save $5 when you spend $9 using our affiliate link Pi-hole Swag Store affiliate link Amazon affiliate link Ho-ost save 50% with our affiliate link DNS Made Easy affiliate link Vultr affiliate link Spreading the word about our software, and how you have benefited from it","title":"Alternative support"},{"location":"#contributing-via-github","text":"We welcome everyone to contribute to issue reports, suggest new features, and create pull requests. If you have something to add - anything from a typo through to a whole new feature, we're happy to check it out! Just make sure to fill out our template when submitting your request; the questions that it asks will help the volunteers quickly understand what you're aiming to achieve. You'll find that the install script and the debug script have an abundance of comments, which will help you better understand how Pi-hole works. They're also a valuable resource to those who want to learn how to write scripts or code a program! We encourage anyone who likes to tinker to read through it, and submit a pull request for us to review.","title":"Contributing via GitHub"},{"location":"#presentations-about-pi-hole","text":"Word-of-mouth continues to help our project grow immensely, and so we are helping make this easier for people. If you are going to be presenting Pi-hole at a conference, meetup or even a school project, get in touch with us so we can hook you up with free swag to hand out to your audience!","title":"Presentations about Pi-hole"},{"location":"#getting-in-touch-with-us","text":"While we are primarily reachable on our Discourse User Forum , we can also be found on a variety of social media outlets. Please be sure to check the FAQ's before starting a new discussion, as we do not have the spare time to reply to every request for assistance. Frequently Asked Questions Pi-hole Wiki Feature Requests Discourse User Forum Reddit Gitter (Real-time chat) Twitter YouTube Facebook","title":"Getting in touch with us"},{"location":"#the-origin-of-pi-hole","text":"Pi-hole being a advertising-aware DNS /Web server , makes use of the following technologies: dnsmasq - a lightweight DNS and DHCP server curl - A command line tool for transferring data with URL syntax lighttpd - webserver designed and optimized for high performance php - a popular general-purpose web scripting language AdminLTE Dashboard - premium admin control panel based on Bootstrap 3.x While quite outdated at this point, this original blog post about Pi-hole goes into great detail about how Pi-hole was originally setup and how it works. Syntactically, it's no longer accurate, but the same basic principles and logic still apply to Pi-hole's current state.","title":"The Origin Of Pi-hole"},{"location":"#pi-hole-projects","text":"The Big Blocklist Collection Docker Pi-hole container (x86 and ARM) Pi-Hole in the cloud Pie in the Sky-Hole [A Pi-Hole in the cloud for ad-blocking via DNS ] Pi-hole Enable/Disable Button Minibian Pi-hole CHiP-hole: Network-wide Ad-blocker Chrome Extension: Pi-Hole List Editor ( Source Code ) Splunk: Pi-hole Visualiser Adblocking with Pi-hole and Ubuntu 14.04 on VirtualBox Pi-hole stats in your Mac's menu bar Pi-hole unRAID Template Copernicus: Windows Tray Application Let your blink1 device blink when Pi-hole filters ads Pi-hole metrics exporter for Prometheus Magic Mirror with DNS Filtering Pi-hole Droid: Android client Windows DNS Swapper , see #1400 Pi-hole Visualizer","title":"Pi-hole Projects"},{"location":"#coverage","text":"Lifehacker: Turn A Raspberry Pi Into An Ad Blocker With A Single Command MakeUseOf: Adblock Everywhere: The Raspberry Pi-Hole Way Catchpoint: Ad-Blocking on Apple iOS9: Valuing the End User Experience Security Now Netcast: Pi-hole TekThing: Raspberry Pi-Hole Makes Ads Disappear! Foolish Tech Show Block Ads on All Home Devices for $53.18 Pi-Hole for Ubuntu 14.04 MacObserver Podcast 585 The Defrag Show: Endoscope USB Camera, The Final [HoloLens] Vote, Adblock Pi and more Adafruit: Pi-hole is a black hole for internet ads Digital Trends: 5 Fun, Easy Projects You Can Try With a $35 Raspberry Pi Adafruit: Raspberry Pi Quick Look at Pi Hole ad blocking server with Tony D Devacron: OrangePi Zero as an Ad-Block server with Pi-Hole Linux Pro: The Hole Truth CryptoAUSTRALIA: How We Tried 5 Privacy Focused Raspberry Pi Projects CryptoAUSTRALIA: Pi-hole Workshop Know How 355: Killing ads with a Raspberry Pi-Hole! Bloomberg: Inside the Brotherhood of the Ad Blockers","title":"Coverage"},{"location":"abbreviations/","text":"","title":"Abbreviations"},{"location":"ftldns/","text":"powered by Pi-hole\u00ae FTL DNS \u2122 ( pihole-FTL ) offers DNS services within the Pi-hole \u00ae project. It provides blazing fast DNS and DHCP services. It can also provide TFTP and more as the resolver part based on the popular dnsmasq . Furthermore, FTL offers an interactive API where extensive network analysis data and statistics may be queried.","title":"Overview"},{"location":"ftldns/blockingmode/","text":"Pi-hole FTL DNS supports two different methods for blocking queries. Both have their advantages and drawbacks. They are summarized on this page. The blocking mode can be configured in /etc/pihole/pihole-FTL.conf . This setting can be updated by sending SIGHUP to pihole-FTL ( sudo killall -SIGHUP pihole-FTL ). Pi-hole's unspecified IP blocking (default) /etc/pihole/pihole-FTL.conf setting: BLOCKINGMODE=NULL Blocked queries will be answered with the unspecified address ;; QUESTION SECTION: ;doubleclick.net. IN ANY ;; ANSWER SECTION: doubleclick.net. 2 IN A 0.0.0.0 doubleclick.net. 2 IN AAAA :: Following RFC 3513, Internet Protocol Version 6 ( IPv6 ) Addressing Architecture, section 2.5.2 , the address 0:0:0:0:0:0:0:0 (or :: for short) is the unspecified address. It must never be assigned to any node and indicates the absence of an address. Following RFC1122, section 3.2 , the address 0.0.0.0 can be understood as the IPv4 equivalent of :: . Advantages The client does not even try to establish a connection for the requested website Speedup and less traffic Solves potential HTTPS timeouts as requests are never performed No need to run a webserver on your Pi-hole (reduces complexity when running other web services on the same machine) Disadvantage Blocking page cannot be shown and whitelisting has to be performed from the dashboard or CLI Pi-hole's IP ( IPv6 NODATA) blocking /etc/pihole/pihole-FTL.conf setting: BLOCKINGMODE=IP-NODATA-AAAA Blocked queries will be answered with the local IPv4 addresses of your Pi-hole (as configured in your setupVars.conf file). Blocked AAAA queries will answered with NODATA-IPV6 and clients will only try to reach your Pi-hole over its static IPv4 address ;; QUESTION SECTION: ;doubleclick.net. IN ANY ;; ANSWER SECTION: doubleclick.net. 2 IN A 192.168.2.11 Advantage Shows blocking page from which blocked domains can be whitelisted Serves IPv4 -only replies and hence mitigates issues with rotating IPv6 prefixes Disadvantages Requires a webserver to run on your Pi-hole May cause time-outs for HTTPS content even with properly configured firewall rules Pi-hole's full IP blocking /etc/pihole/pihole-FTL.conf setting: BLOCKINGMODE=IP Blocked queries will be answered with the local IP addresses of your Pi-hole (as configured in your setupVars.conf file) ;; QUESTION SECTION: ;doubleclick.net. IN ANY ;; ANSWER SECTION: doubleclick.net. 2 IN A 192.168.2.11 doubleclick.net. 2 IN AAAA fda2:2001:4756:0:ab27:beff:ef37:4242 Advantage Shows blocking page from which blocked domains can be whitelisted Disadvantages Requires a webserver to run on your Pi-hole May cause time-outs for HTTPS content even with properly configured firewall rules May cause problems with alternating prefixes on IPv6 addresses (see IP-AAAA-NODATA ) Pi-hole's NXDOMAIN blocking /etc/pihole/pihole-FTL.conf setting: BLOCKINGMODE=NXDOMAIN Blocked queries will be answered with an empty response (no answer section) and status NXDOMAIN ( no such domain ) ;; QUESTION SECTION: ;doubleclick.net. IN ANY Advantages Disadvantages Similar to NULL blocking, but experiments suggest that clients may try to resolve blocked domains more often compared to NULL blocking.","title":"Blocking mode"},{"location":"ftldns/blockingmode/#pi-holes-unspecified-ip-blocking-default","text":"/etc/pihole/pihole-FTL.conf setting: BLOCKINGMODE=NULL Blocked queries will be answered with the unspecified address ;; QUESTION SECTION: ;doubleclick.net. IN ANY ;; ANSWER SECTION: doubleclick.net. 2 IN A 0.0.0.0 doubleclick.net. 2 IN AAAA :: Following RFC 3513, Internet Protocol Version 6 ( IPv6 ) Addressing Architecture, section 2.5.2 , the address 0:0:0:0:0:0:0:0 (or :: for short) is the unspecified address. It must never be assigned to any node and indicates the absence of an address. Following RFC1122, section 3.2 , the address 0.0.0.0 can be understood as the IPv4 equivalent of :: .","title":"Pi-hole's unspecified IP blocking (default)"},{"location":"ftldns/blockingmode/#advantages","text":"The client does not even try to establish a connection for the requested website Speedup and less traffic Solves potential HTTPS timeouts as requests are never performed No need to run a webserver on your Pi-hole (reduces complexity when running other web services on the same machine)","title":"Advantages"},{"location":"ftldns/blockingmode/#disadvantage","text":"Blocking page cannot be shown and whitelisting has to be performed from the dashboard or CLI","title":"Disadvantage"},{"location":"ftldns/blockingmode/#pi-holes-ip-ipv6-nodata-blocking","text":"/etc/pihole/pihole-FTL.conf setting: BLOCKINGMODE=IP-NODATA-AAAA Blocked queries will be answered with the local IPv4 addresses of your Pi-hole (as configured in your setupVars.conf file). Blocked AAAA queries will answered with NODATA-IPV6 and clients will only try to reach your Pi-hole over its static IPv4 address ;; QUESTION SECTION: ;doubleclick.net. IN ANY ;; ANSWER SECTION: doubleclick.net. 2 IN A 192.168.2.11","title":"Pi-hole's IP (IPv6 NODATA) blocking"},{"location":"ftldns/blockingmode/#advantage","text":"Shows blocking page from which blocked domains can be whitelisted Serves IPv4 -only replies and hence mitigates issues with rotating IPv6 prefixes","title":"Advantage"},{"location":"ftldns/blockingmode/#disadvantages","text":"Requires a webserver to run on your Pi-hole May cause time-outs for HTTPS content even with properly configured firewall rules","title":"Disadvantages"},{"location":"ftldns/blockingmode/#pi-holes-full-ip-blocking","text":"/etc/pihole/pihole-FTL.conf setting: BLOCKINGMODE=IP Blocked queries will be answered with the local IP addresses of your Pi-hole (as configured in your setupVars.conf file) ;; QUESTION SECTION: ;doubleclick.net. IN ANY ;; ANSWER SECTION: doubleclick.net. 2 IN A 192.168.2.11 doubleclick.net. 2 IN AAAA fda2:2001:4756:0:ab27:beff:ef37:4242","title":"Pi-hole's full IP blocking"},{"location":"ftldns/blockingmode/#advantage_1","text":"Shows blocking page from which blocked domains can be whitelisted","title":"Advantage"},{"location":"ftldns/blockingmode/#disadvantages_1","text":"Requires a webserver to run on your Pi-hole May cause time-outs for HTTPS content even with properly configured firewall rules May cause problems with alternating prefixes on IPv6 addresses (see IP-AAAA-NODATA )","title":"Disadvantages"},{"location":"ftldns/blockingmode/#pi-holes-nxdomain-blocking","text":"/etc/pihole/pihole-FTL.conf setting: BLOCKINGMODE=NXDOMAIN Blocked queries will be answered with an empty response (no answer section) and status NXDOMAIN ( no such domain ) ;; QUESTION SECTION: ;doubleclick.net. IN ANY","title":"Pi-hole's NXDOMAIN blocking"},{"location":"ftldns/blockingmode/#advantages-disadvantages","text":"Similar to NULL blocking, but experiments suggest that clients may try to resolve blocked domains more often compared to NULL blocking.","title":"Advantages &amp; Disadvantages"},{"location":"ftldns/compatibility/","text":"FTL DNS compatibility list We tested FTL DNS on the following devices: Board Tested OS CPU architecture Suitable binaries VirtualBox Ubuntu 16.10 amd64 linux-x86_64 Raspberry Pi Zero Raspbian Jessie, Stretch armv6l arm-linux-gnueabi Raspberry Pi 1 Raspbian Jessie, Stretch armv6 arm-linux-gnueabi Raspberry Pi 2 Raspbian Jessie, Stretch armv7l arm-linux-gnueabihf and arm-linux-gnuabi Raspberry Pi 3 Raspbian Jessie, Stretch armv7l arm-linux-gnuabi and arm-linux-gnueabihf Raspberry Pi 3 B+ Raspbian Jessie, Stretch armv7l arm-linux-gnuabi and arm-linux-gnueabihf Raspberry Pi 3 openSUSE aarch64 aarch64-linux-gnu NanoPi NEO armbian Ubuntu 16.04 armv7l arm-linux-gnueabihf Odroid-C2 Ubuntu 16.04 aarch64 aarch64-linux-gnu C.H.I.P Debian armv7l arm-linux-gnueabihf OrangePi Zero armbian Ubuntu 16.04 armv7l arm-linux-gnueabihf BeagleBone Black Debian Jessie, Stretch armv7l arm-linux-gnueabihf Devices we do not officially support include MIPS and armv5 (or lower) devices. You may, however, be successful with building binaries yourself from the source code, but we do not provide pre-built binaries for these targets.","title":"Compatibility"},{"location":"ftldns/compatibility/#ftldns-compatibility-list","text":"We tested FTL DNS on the following devices: Board Tested OS CPU architecture Suitable binaries VirtualBox Ubuntu 16.10 amd64 linux-x86_64 Raspberry Pi Zero Raspbian Jessie, Stretch armv6l arm-linux-gnueabi Raspberry Pi 1 Raspbian Jessie, Stretch armv6 arm-linux-gnueabi Raspberry Pi 2 Raspbian Jessie, Stretch armv7l arm-linux-gnueabihf and arm-linux-gnuabi Raspberry Pi 3 Raspbian Jessie, Stretch armv7l arm-linux-gnuabi and arm-linux-gnueabihf Raspberry Pi 3 B+ Raspbian Jessie, Stretch armv7l arm-linux-gnuabi and arm-linux-gnueabihf Raspberry Pi 3 openSUSE aarch64 aarch64-linux-gnu NanoPi NEO armbian Ubuntu 16.04 armv7l arm-linux-gnueabihf Odroid-C2 Ubuntu 16.04 aarch64 aarch64-linux-gnu C.H.I.P Debian armv7l arm-linux-gnueabihf OrangePi Zero armbian Ubuntu 16.04 armv7l arm-linux-gnueabihf BeagleBone Black Debian Jessie, Stretch armv7l arm-linux-gnueabihf Devices we do not officially support include MIPS and armv5 (or lower) devices. You may, however, be successful with building binaries yourself from the source code, but we do not provide pre-built binaries for these targets.","title":"FTLDNS compatibility list"},{"location":"ftldns/compile/","text":"We pre-compile FTL DNS for you to save you the trouble of compiling anything yourself. However, sometimes you may want to make your own modifications. To test them, you have to compile FTL DNS from source. Luckily, you don't have to be a programmer to build FTL DNS from source and install it on your system; you only have to know the basics we provide in here. With just a few commands, you can build FTL DNS from source like a pro. Installing the Required Software First, we'll install the basic software you'll need to compile from source, like the GCC compiler and other utilities. Install them by running the following command in a terminal: sudo apt install build-essential libgmp-dev m4 You'll also need to compile a recent version of nettle as FTL DNS uses libnettle for handling DNSSEC. Compile and install a recent version of nettle (we tested 3.4): wget https://ftp.gnu.org/gnu/nettle/nettle-3.4.tar.gz tar -xvzf nettle-3.4.tar.gz cd nettle-3.4 ./configure make sudo make install Get the FTL DNS source Now, clone the FTL DNS repo (or your own fork) to get the source code of FTL DNS : git clone https://github.com/pi-hole/FTL.git cd FTL If you want to build another branch and not master , use checkout to get to this branch (e.g. git checkout development ). FTL DNS can now be compiled and installed: make -j 4 sudo make install Finally, restart FTL DNS to use the new binary: sudo service pihole-FTL restart","title":"Install from source"},{"location":"ftldns/compile/#installing-the-required-software","text":"First, we'll install the basic software you'll need to compile from source, like the GCC compiler and other utilities. Install them by running the following command in a terminal: sudo apt install build-essential libgmp-dev m4 You'll also need to compile a recent version of nettle as FTL DNS uses libnettle for handling DNSSEC. Compile and install a recent version of nettle (we tested 3.4): wget https://ftp.gnu.org/gnu/nettle/nettle-3.4.tar.gz tar -xvzf nettle-3.4.tar.gz cd nettle-3.4 ./configure make sudo make install","title":"Installing the Required Software"},{"location":"ftldns/compile/#get-the-ftldns-source","text":"Now, clone the FTL DNS repo (or your own fork) to get the source code of FTL DNS : git clone https://github.com/pi-hole/FTL.git cd FTL If you want to build another branch and not master , use checkout to get to this branch (e.g. git checkout development ). FTL DNS can now be compiled and installed: make -j 4 sudo make install Finally, restart FTL DNS to use the new binary: sudo service pihole-FTL restart","title":"Get the FTLDNS source"},{"location":"ftldns/configfile/","text":"You can create a file /etc/pihole/pihole-FTL.conf that will be read by FTL DNS on startup. Possible settings ( the option shown first is the default ): SOCKET_LISTENING SOCKET_LISTENING=localonly|all Listen only for local socket connections or permit all connections AAAA_QUERY_ANALYSIS AAAA_QUERY_ANALYSIS=yes|no Allow FTL to analyze AAAA queries from pihole.log? ANALYZE_ONLY_A_AND_AAAA ANALYZE_ONLY_A_AND_AAAA=false|true Should FTL only analyze A and AAAA queries? RESOLVE_IPV6 RESOLVE_IPV6=yes|no Should FTL try to resolve IPv6 addresses to host names? RESOLVE_IPV4 RESOLVE_IPV4=yes|no Should FTL try to resolve IPv4 addresses to host names? MAXDBDAYS MAXDBDAYS=365 How long should queries be stored in the database? Setting this to 0 disables the database More details DBINTERVAL DBINTERVAL=1.0 How often do we store queries in FTL 's database [minutes]? More details DBFILE DBFILE=/etc/pihole/pihole-FTL.db Specify path and filename of FTL 's SQLite3 long-term database. Setting this to DBFILE= disables the database altogether More details MAXLOGAGE MAXLOGAGE=24.0 Up to how many hours of queries should be imported from the database and logs? Maximum is 744 (31 days) FTLPORT FTLPORT=4711 On which port should FTL be listening? PRIVACYLEVEL PRIVACYLEVEL=0|1|2|3|4 Which privacy level is used? More details IGNORE_LOCALHOST IGNORE_LOCALHOST=no|yes Should FTL ignore queries coming from the local machine? BLOCKINGMODE BLOCKINGMODE=NULL|IP-AAAA-NODATA|IP|NXDOMAIN How should FTL reply to blocked queries? More details REGEX_DEBUGMODE REGEX_DEBUGMODE=false|true Controls if FTL DNS should print extended details about regex matching into pihole-FTL.log . More details DBIMPORT DBIMPORT=yes|no Should FTL load information from the database on startup to be aware of the most recent history? More details","title":"Configuration"},{"location":"ftldns/configfile/#socket_listening","text":"SOCKET_LISTENING=localonly|all Listen only for local socket connections or permit all connections","title":"SOCKET_LISTENING"},{"location":"ftldns/configfile/#aaaa_query_analysis","text":"AAAA_QUERY_ANALYSIS=yes|no Allow FTL to analyze AAAA queries from pihole.log?","title":"AAAA_QUERY_ANALYSIS"},{"location":"ftldns/configfile/#analyze_only_a_and_aaaa","text":"ANALYZE_ONLY_A_AND_AAAA=false|true Should FTL only analyze A and AAAA queries?","title":"ANALYZE_ONLY_A_AND_AAAA"},{"location":"ftldns/configfile/#resolve_ipv6","text":"RESOLVE_IPV6=yes|no Should FTL try to resolve IPv6 addresses to host names?","title":"RESOLVE_IPV6"},{"location":"ftldns/configfile/#resolve_ipv4","text":"RESOLVE_IPV4=yes|no Should FTL try to resolve IPv4 addresses to host names?","title":"RESOLVE_IPV4"},{"location":"ftldns/configfile/#maxdbdays","text":"MAXDBDAYS=365 How long should queries be stored in the database? Setting this to 0 disables the database More details","title":"MAXDBDAYS"},{"location":"ftldns/configfile/#dbinterval","text":"DBINTERVAL=1.0 How often do we store queries in FTL 's database [minutes]? More details","title":"DBINTERVAL"},{"location":"ftldns/configfile/#dbfile","text":"DBFILE=/etc/pihole/pihole-FTL.db Specify path and filename of FTL 's SQLite3 long-term database. Setting this to DBFILE= disables the database altogether More details","title":"DBFILE"},{"location":"ftldns/configfile/#maxlogage","text":"MAXLOGAGE=24.0 Up to how many hours of queries should be imported from the database and logs? Maximum is 744 (31 days)","title":"MAXLOGAGE"},{"location":"ftldns/configfile/#ftlport","text":"FTLPORT=4711 On which port should FTL be listening?","title":"FTLPORT"},{"location":"ftldns/configfile/#privacylevel","text":"PRIVACYLEVEL=0|1|2|3|4 Which privacy level is used? More details","title":"PRIVACYLEVEL"},{"location":"ftldns/configfile/#ignore_localhost","text":"IGNORE_LOCALHOST=no|yes Should FTL ignore queries coming from the local machine?","title":"IGNORE_LOCALHOST"},{"location":"ftldns/configfile/#blockingmode","text":"BLOCKINGMODE=NULL|IP-AAAA-NODATA|IP|NXDOMAIN How should FTL reply to blocked queries? More details","title":"BLOCKINGMODE"},{"location":"ftldns/configfile/#regex_debugmode","text":"REGEX_DEBUGMODE=false|true Controls if FTL DNS should print extended details about regex matching into pihole-FTL.log . More details","title":"REGEX_DEBUGMODE"},{"location":"ftldns/configfile/#dbimport","text":"DBIMPORT=yes|no Should FTL load information from the database on startup to be aware of the most recent history? More details","title":"DBIMPORT"},{"location":"ftldns/database/","text":"Pi-hole FTL DNS uses the well-known relational database management system SQLite3 as it's long-term storage of query data. In contrast to many other database management solutions, FTL DNS does not need a server database engine as the database engine is directly embedded in FTL DNS . It seems an obvious choice as it is probably the most widely deployed database engine - it is used today by several widespread web browsers, operating systems, and embedded systems (such as mobile phones), among others. Hence, it is rich in supported platforms and offered features. SQLite implements most of the SQL-92 standard for SQL and can be used for high-level queries. We update the database file periodically and on exit of FTL DNS (triggered e.g. by a service pihole-FTL restart ). The updating frequency can be controlled by the parameter DBINTERVAL and defaults to once per minute. We think this interval is sufficient to protect against data losses due to power failure events. FTL DNS needs the database to populate its internal history of the most recent 24 hours. If the database is disabled, FTL DNS will show an empty query history after a restart. The location of the database can be configures by the config parameter DBFILE . It defaults to /etc/pihole/pihole-FTL.db . If the given file does not exist, FTL DNS will create a new (empty) database file. You can split your long-term database by periodically rotating the database file (do this only when pihole-FTL is not running). The individual database contents can easily be merged when required. This could be implemented by running a monthly cron job such as: sudo service pihole-FTL stop sudo mv /etc/pihole/pihole-FTL.db /media/backup/pihole-FTL_$(date + %m-%y ).db sudo service pihole-FTL start Note that DNS resolution will not be available as long as pihole-FTL is stopped. Another way of controlling the size of the long-term database is setting a maximum age for log queries to keep using the config parameter MAXDBDAYS . It defaults to 365 days, i.e. queries that are older than one year get periodically removed to limit the growth of the long-term database file. The config parameter DBIMPORT controls whether FTL loads information from the database on startup. It need to do this to populate the internal datastructure with the most recent history. However, as importing from the database on disk can delay FTL on very large deploys, it can be disabled using this option. The long-term database contains three tables: Query Table Label Type Allowed to by empty Content id integer No autoincrement ID for the table, only used by SQLite3 , not by FTL DNS timestamp integer No Unix timestamp when this query arrived at FTL DNS (used as index) type integer No Type of this query (see Supported query types ) status integer No How was this query handled by FTL DNS ? (see Supported status types ) domain text No Requested domain client text No Requesting client ( IP address) forward text Yes Forward destination used for this query (only set if status == 2 ) SQLite3 syntax used to create this table: CREATE TABLE queries ( id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp INTEGER NOT NULL, type INTEGER NOT NULL, status INTEGER NOT NULL, domain TEXT NOT NULL, client TEXT NOT NULL, forward TEXT ); CREATE INDEX idx_queries_timestamps ON queries (timestamp); Counters table This table contains counter values integrated over the entire lifetime of the table Label Type Allowed to by empty Content id integer No ID for the table used to select a counter (see below) value integer No Value of a given counter Counter ID Interpretation 0 Total number of queries 1 Total number of blocked queries (Query status 1, 4 or 5) SQLite3 syntax used to create this table: CREATE TABLE counters ( id INTEGER PRIMARY KEY NOT NULL, value INTEGER NOT NULL ); FTL table The FTL tables contains some data used by FTL DNS for determining which queries to save to the database. This table does not contain any entries of general interest. SQLite3 syntax used to create this table: CREATE TABLE ftl ( id INTEGER PRIMARY KEY NOT NULL, value BLOB NOT NULL ); Supported query types ID Query Type 1 A 2 AAAA 3 ANY 4 SRV 5 SOA 6 PTR 7 TXT Supported status types ID Query Type 0 Unknown status (was not answered by forward destination) 1 Blocked by gravity.list 2 Permitted + forwarded 3 Permitted + replied to from cache 4 Blocked by wildcard 5 Blocked by black.list Example for interaction with the FTL long-term database In addition to the interactions the Pi-hole database API offers, you can also run your own SQL commands against the database. If you want to obtain the three most queries domains for all time, you could use sqlite3 /etc/pihole/pihole-FTL.db SELECT domain,count(domain) FROM queries WHERE (STATUS == 2 OR STATUS == 3) GROUP by domain order by count(domain) desc limit 3 which would return something like discourse.pi-hole.net|421095 www.pi-hole.net|132483 posteo.de|130243 showing the domain and the number of times it was found in the long-term database. Note that such a request might take very long for computation as the entire history of queries have to be processed for this.","title":"Long-term database"},{"location":"ftldns/database/#query-table","text":"Label Type Allowed to by empty Content id integer No autoincrement ID for the table, only used by SQLite3 , not by FTL DNS timestamp integer No Unix timestamp when this query arrived at FTL DNS (used as index) type integer No Type of this query (see Supported query types ) status integer No How was this query handled by FTL DNS ? (see Supported status types ) domain text No Requested domain client text No Requesting client ( IP address) forward text Yes Forward destination used for this query (only set if status == 2 ) SQLite3 syntax used to create this table: CREATE TABLE queries ( id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp INTEGER NOT NULL, type INTEGER NOT NULL, status INTEGER NOT NULL, domain TEXT NOT NULL, client TEXT NOT NULL, forward TEXT ); CREATE INDEX idx_queries_timestamps ON queries (timestamp);","title":"Query Table"},{"location":"ftldns/database/#counters-table","text":"This table contains counter values integrated over the entire lifetime of the table Label Type Allowed to by empty Content id integer No ID for the table used to select a counter (see below) value integer No Value of a given counter Counter ID Interpretation 0 Total number of queries 1 Total number of blocked queries (Query status 1, 4 or 5) SQLite3 syntax used to create this table: CREATE TABLE counters ( id INTEGER PRIMARY KEY NOT NULL, value INTEGER NOT NULL );","title":"Counters table"},{"location":"ftldns/database/#ftl-table","text":"The FTL tables contains some data used by FTL DNS for determining which queries to save to the database. This table does not contain any entries of general interest. SQLite3 syntax used to create this table: CREATE TABLE ftl ( id INTEGER PRIMARY KEY NOT NULL, value BLOB NOT NULL );","title":"FTL table"},{"location":"ftldns/database/#supported-query-types","text":"ID Query Type 1 A 2 AAAA 3 ANY 4 SRV 5 SOA 6 PTR 7 TXT","title":"Supported query types"},{"location":"ftldns/database/#supported-status-types","text":"ID Query Type 0 Unknown status (was not answered by forward destination) 1 Blocked by gravity.list 2 Permitted + forwarded 3 Permitted + replied to from cache 4 Blocked by wildcard 5 Blocked by black.list","title":"Supported status types"},{"location":"ftldns/database/#example-for-interaction-with-the-ftl-long-term-database","text":"In addition to the interactions the Pi-hole database API offers, you can also run your own SQL commands against the database. If you want to obtain the three most queries domains for all time, you could use sqlite3 /etc/pihole/pihole-FTL.db SELECT domain,count(domain) FROM queries WHERE (STATUS == 2 OR STATUS == 3) GROUP by domain order by count(domain) desc limit 3 which would return something like discourse.pi-hole.net|421095 www.pi-hole.net|132483 posteo.de|130243 showing the domain and the number of times it was found in the long-term database. Note that such a request might take very long for computation as the entire history of queries have to be processed for this.","title":"Example for interaction with the FTL long-term database"},{"location":"ftldns/debugging/","text":"Once you are used to it, you can skip most of the steps. Debugging FTL DNS is actually quite easy as pihole-FTL has been designed such that a debugger can be attached to an already running process. It can give you insights into how software (not limited to pihole-FTL ) works. Install screen and gdb using sudo apt-get install screen gdb Start a screen session (it will allow you to come back even if the SSH connection died) If you don't know about screen , then read about it (you will love it!) Start a screen session using screen Use sudo gdb -p $(pidof pihole-FTL) to attach the debugger to the already running pihole-FTL process Once loading of the symbols has finished (the (gdb) input prompt is shown), run handle SIGHUP nostop SIGPIPE nostop Enter continue to continue operation of pihole-FTL inside the debugger. All debugger features are now available. When pihole-FTL has crashed, copy paste the terminal output into a (new) issue. Also type backtrace and include its output. We might ask for additional information in order to isolate your particular issue.","title":"Debugging FTLDNS"},{"location":"ftldns/dns-cache/","text":"pihole-FTL offers an efficient DNS cache that helps speed up your Internet experience. This DNS cache is part of the embedded dnsmasq server. Setting the cache size to zero disables caching. The DNS TTL value is used for determining the caching period. pihole-FTL clears its cache on receiving SIGHUP . Cache metrics The Settings page (System panel, FTL table) gives live information about the cache usage. It obtains its information from http://pi.hole/admin/api.php?getCacheInfo . DNS cache size Size of the DNS domain cache, defaulting to 10,000 entries. You typically specify this number directly in /etc/dnsmasq.d/01-pihole.conf . It is the number of entries that can be actively cached at the same time. There is no benefit in enlarging this number except if the DNS cache evictions count is larger than zero. This information may also be queried using dig +short chaos txt cachesize.bind DNS cache insertions Number of total insertions into the cache. This number can be substantially larger than DNS cache size as expiring cache entries naturally make room for new insertions over time. Each lookup with a non-zero TTL will be cached. This information may also be queried using dig +short chaos txt insertions.bind DNS cache evictions Number of cache entries that had to be removed although the corresponding entries were not expired. Old cache entries get removed if the cache is full to make space for more recent domains. The cache size should be increased when this number is larger than zero. This information may also be queried using dig +short chaos txt evictions.bind","title":"DNS cache"},{"location":"ftldns/dns-cache/#cache-metrics","text":"The Settings page (System panel, FTL table) gives live information about the cache usage. It obtains its information from http://pi.hole/admin/api.php?getCacheInfo .","title":"Cache metrics"},{"location":"ftldns/dns-cache/#dns-cache-size","text":"Size of the DNS domain cache, defaulting to 10,000 entries. You typically specify this number directly in /etc/dnsmasq.d/01-pihole.conf . It is the number of entries that can be actively cached at the same time. There is no benefit in enlarging this number except if the DNS cache evictions count is larger than zero. This information may also be queried using dig +short chaos txt cachesize.bind","title":"DNS cache size"},{"location":"ftldns/dns-cache/#dns-cache-insertions","text":"Number of total insertions into the cache. This number can be substantially larger than DNS cache size as expiring cache entries naturally make room for new insertions over time. Each lookup with a non-zero TTL will be cached. This information may also be queried using dig +short chaos txt insertions.bind","title":"DNS cache insertions"},{"location":"ftldns/dns-cache/#dns-cache-evictions","text":"Number of cache entries that had to be removed although the corresponding entries were not expired. Old cache entries get removed if the cache is full to make space for more recent domains. The cache size should be increased when this number is larger than zero. This information may also be queried using dig +short chaos txt evictions.bind","title":"DNS cache evictions"},{"location":"ftldns/dns-resolver/","text":"FTL DNS comes with a lightweight but powerful inbuilt DNS / DHCP / TFTP /... server eliminating the need to install dnsmasq separately (we used to do this before Pi-hole v4.0). However, it is important to understand that we are not moving away from dnsmasq , but, in contrast, are coupling even closer to it by incorporating it into FTL . This provides us with a much more reliable monolith DNS solution where we can be sure that the versions of FTL and the DNS internals are always 100% compatible with each other. As we maintain our own fork of dnsmasq we have been able to apply some minimal changes to the source code which might bring substantial benefits for our users. However, although the potential for changes is endless, we want to include as few modifications as possible. As a purely volunteer driven project, you will surely understand that it was already a major undertaking to get FTL DNS set up and running. It was much more than just copy-pasting dnsmasq into place. We have always been very explicit about how we will react to feature requests that target the resolver part (from the initial FTL DNS beta test announcement): Think of FTL DNS as dnsmasq with Pi-hole\u2019s special sauce. This allows us to easily merge any upstream changes that get added, while still allowing us to continue to develop Pi-hole as we have been. If we would start to modify the resolver code in too many places, then this would probably make us deviate too much from dnsmasq 's code base and we couldn't apply patches easily preventing us from being able to ship important security updates. Implemented modifications in dnsmasq 's source code FTL hooks We place hooks in a lot of places in the resolver that branch out into FTL code to process queries and responses. By this, we keep the resolver code itself clean. Remove limit on maximum cache size Users are able to configure the size of the resolvers name cache. The default is 150 names. Setting the cache size to zero disables caching. We think users should be allowed to set the cache size to any value they find appropriate. However, dnsmasq 's source code contains a condition that limits the maximum size of the cache to 10,000 names. We removed this hard-coded upper limit in option.c and submitted a patch to remove this hard-coded limit in the upstream version of dnsmasq . Improve detection algorithm for determining the \"best\" forward destination The DNS forward destination determination algorithm in FTL DNS 's is modified to be much less restrictive than the original algorithm in dnsmasq . We keep using the fastest responding server now for 1000 queries or 10 minutes (whatever happens earlier) instead of 50 queries or 10 seconds (default values in dnsmasq ). We keep the exceptions, i.e., we try all possible forward destinations if SERVFAIL or REFUSED is received or if a timeout occurs. Overall, this change has proven to greatly reduce the number of actually performed queries in typical Pi-hole environments. It may even be understood as being preferential in terms of privacy (as we send queries much less often to all servers). This has been implemented in commit d1c163e on the FTLDNS branch.","title":"DNS resolver"},{"location":"ftldns/dns-resolver/#implemented-modifications-in-dnsmasqs-source-code","text":"","title":"Implemented modifications in dnsmasq's source code"},{"location":"ftldns/dns-resolver/#ftl-hooks","text":"We place hooks in a lot of places in the resolver that branch out into FTL code to process queries and responses. By this, we keep the resolver code itself clean.","title":"FTL hooks"},{"location":"ftldns/dns-resolver/#remove-limit-on-maximum-cache-size","text":"Users are able to configure the size of the resolvers name cache. The default is 150 names. Setting the cache size to zero disables caching. We think users should be allowed to set the cache size to any value they find appropriate. However, dnsmasq 's source code contains a condition that limits the maximum size of the cache to 10,000 names. We removed this hard-coded upper limit in option.c and submitted a patch to remove this hard-coded limit in the upstream version of dnsmasq .","title":"Remove limit on maximum cache size"},{"location":"ftldns/dns-resolver/#improve-detection-algorithm-for-determining-the-best-forward-destination","text":"The DNS forward destination determination algorithm in FTL DNS 's is modified to be much less restrictive than the original algorithm in dnsmasq . We keep using the fastest responding server now for 1000 queries or 10 minutes (whatever happens earlier) instead of 50 queries or 10 seconds (default values in dnsmasq ). We keep the exceptions, i.e., we try all possible forward destinations if SERVFAIL or REFUSED is received or if a timeout occurs. Overall, this change has proven to greatly reduce the number of actually performed queries in typical Pi-hole environments. It may even be understood as being preferential in terms of privacy (as we send queries much less often to all servers). This has been implemented in commit d1c163e on the FTLDNS branch.","title":"Improve detection algorithm for determining the \"best\" forward destination"},{"location":"ftldns/in-depth/","text":"Available interfaces Pi-hole stats can be accessed via a standard Unix socket ( var/run/pihole/FTL.sock ), a telnet-like connection ( TCP socket on port 4711 ) as well as indirectly via the Web API ( admin/api.php ), and command line ( pihole -c -j ). You can out find more details below. Command line arguments debug - Don't go into daemon mode (stay in foreground) + more verbose logging test - Start FTL and process everything, but shut down immediately afterwards version - Don't start FTL , show only version tag - Don't start FTL , show only git tag branch - Don't start FTL , show only git branch FTL was compiled from no-daemon or -f - Don't go into background (daemon mode) help or -h - Don't start FTL , show help dnsmasq-test - Test resolver config file syntax -- everything behind -- will be passed as options to the internal resolver Command line arguments can be arbitrarily combined, e.g. pihole-FTL debug test File locations /var/log/pihole-FTL.log log file /var/run/pihole-FTL.pid PID file /var/run/pihole-FTL.port file containing port on which FTL is listening /var/run/pihole/FTL.sock Unix socket Domain lists format Since Pi-hole v4.0, we use a simpler domain list format for the two important block list files gravity.list and black.list . In contrast to the traditional HOSTS format (which caused a lot of overhead), the domain list format is the minimal possible solution for saving memory while still using plain text lists for your convenience. When FTL DNS imports these two files, they are walked by our improved list parser speeding up the loading of block lists significantly. Regardless which blocking mode ( IP or NXDOMAIN ) is selected, FTL DNS will always load the lists into it's internal hashed cache to be able to determine the blocking status within a few milliseconds, even when you're using huge blocking lists on low-end devices. With everything we do, we design FTL DNS for maximum efficiency also on low-performance devices. Linux capabilities Capabilities ( POSIX 1003.1e, capabilities(7) ) provide fine-grained control over superuser permissions, allowing use of the root user to be avoided. For the purpose of performing permission checks, traditional UNIX implementations distinguish two categories of processes: privileged processes (superuser or root ), and unprivileged processes . Privileged processes bypass all kernel permission checks, while unprivileged processes are subject to full permission checking based on the process's credentials (user and group permissions and supplementary process capabilities). Capabilities are implemented on Linux using extended attributes ( xattr(7) ) in the security namespace. Extended attributes are supported by all major Linux file systems, including Ext2 , Ext3 , Ext4 , Btrfs , JFS , XFS , and ReiserFS . For your safety and comfort, pihole-FTL is run by the entirely unprivileged user pihole . Whereas dnsmasq is running as root process, we designed pihole-FTL to be run by the entirely unprivileged user pihole . As a consequence, pihole-FTL will not be able to access the files of any other user on this system or mess around with your system's configuration. However, this also implies that FTL DNS cannot bind to ports 53 ( DNS ) among some other necessary capabilities related to DHCP services. To establish a strong security model, we explicitly grant the pihole-FTL process additional capabilities so that pihole-FTL (but no other processes which may be started by pihole ) can bind to port 53, etc., without giving any additional permissions to the pihole user. We specifically add the following capabilities to pihole-FTL : CAP_NET_BIND_SERVICE : Allows FTL DNS binding to TCP / UDP sockets below 1024 (specifically DNS service on port 53) CAP_NET_RAW : use raw and packet sockets (we need a RAW socket for handling DHCPv6 requests) CAP_NET_ADMIN : modify routing tables and other network-related operations (to allow for handling DHCP requests) Users that cannot use Linux capabilites for various reasons (lacking kernel or file system support) can modify the startup scripts of pihole-FTL to ensure the daemon is started as root . However, be aware of that you do so on your own risk (although we don't expect problems to arise).","title":"In-depth manual"},{"location":"ftldns/in-depth/#available-interfaces","text":"Pi-hole stats can be accessed via a standard Unix socket ( var/run/pihole/FTL.sock ), a telnet-like connection ( TCP socket on port 4711 ) as well as indirectly via the Web API ( admin/api.php ), and command line ( pihole -c -j ). You can out find more details below.","title":"Available interfaces"},{"location":"ftldns/in-depth/#command-line-arguments","text":"debug - Don't go into daemon mode (stay in foreground) + more verbose logging test - Start FTL and process everything, but shut down immediately afterwards version - Don't start FTL , show only version tag - Don't start FTL , show only git tag branch - Don't start FTL , show only git branch FTL was compiled from no-daemon or -f - Don't go into background (daemon mode) help or -h - Don't start FTL , show help dnsmasq-test - Test resolver config file syntax -- everything behind -- will be passed as options to the internal resolver Command line arguments can be arbitrarily combined, e.g. pihole-FTL debug test","title":"Command line arguments"},{"location":"ftldns/in-depth/#file-locations","text":"/var/log/pihole-FTL.log log file /var/run/pihole-FTL.pid PID file /var/run/pihole-FTL.port file containing port on which FTL is listening /var/run/pihole/FTL.sock Unix socket","title":"File locations"},{"location":"ftldns/in-depth/#domain-lists-format","text":"Since Pi-hole v4.0, we use a simpler domain list format for the two important block list files gravity.list and black.list . In contrast to the traditional HOSTS format (which caused a lot of overhead), the domain list format is the minimal possible solution for saving memory while still using plain text lists for your convenience. When FTL DNS imports these two files, they are walked by our improved list parser speeding up the loading of block lists significantly. Regardless which blocking mode ( IP or NXDOMAIN ) is selected, FTL DNS will always load the lists into it's internal hashed cache to be able to determine the blocking status within a few milliseconds, even when you're using huge blocking lists on low-end devices. With everything we do, we design FTL DNS for maximum efficiency also on low-performance devices.","title":"Domain lists format"},{"location":"ftldns/in-depth/#linux-capabilities","text":"Capabilities ( POSIX 1003.1e, capabilities(7) ) provide fine-grained control over superuser permissions, allowing use of the root user to be avoided. For the purpose of performing permission checks, traditional UNIX implementations distinguish two categories of processes: privileged processes (superuser or root ), and unprivileged processes . Privileged processes bypass all kernel permission checks, while unprivileged processes are subject to full permission checking based on the process's credentials (user and group permissions and supplementary process capabilities). Capabilities are implemented on Linux using extended attributes ( xattr(7) ) in the security namespace. Extended attributes are supported by all major Linux file systems, including Ext2 , Ext3 , Ext4 , Btrfs , JFS , XFS , and ReiserFS . For your safety and comfort, pihole-FTL is run by the entirely unprivileged user pihole . Whereas dnsmasq is running as root process, we designed pihole-FTL to be run by the entirely unprivileged user pihole . As a consequence, pihole-FTL will not be able to access the files of any other user on this system or mess around with your system's configuration. However, this also implies that FTL DNS cannot bind to ports 53 ( DNS ) among some other necessary capabilities related to DHCP services. To establish a strong security model, we explicitly grant the pihole-FTL process additional capabilities so that pihole-FTL (but no other processes which may be started by pihole ) can bind to port 53, etc., without giving any additional permissions to the pihole user. We specifically add the following capabilities to pihole-FTL : CAP_NET_BIND_SERVICE : Allows FTL DNS binding to TCP / UDP sockets below 1024 (specifically DNS service on port 53) CAP_NET_RAW : use raw and packet sockets (we need a RAW socket for handling DHCPv6 requests) CAP_NET_ADMIN : modify routing tables and other network-related operations (to allow for handling DHCP requests) Users that cannot use Linux capabilites for various reasons (lacking kernel or file system support) can modify the startup scripts of pihole-FTL to ensure the daemon is started as root . However, be aware of that you do so on your own risk (although we don't expect problems to arise).","title":"Linux capabilities"},{"location":"ftldns/privacylevels/","text":"Using privacy levels you can specify which level of detail you want to see in your Pi-hole statistics. The privacy level may be changed at any time without having to restart the DNS resolver. Note that queries with (partially) hidden details cannot be disclosed with a subsequent reduction of the privacy level. They can be changed either from the Settings page on the dashboard or in FTL 's config file . The available options are Level 0 - show everything Doesn't hide anything, all statistics are available Level 1 - hide domains Show and store all domains as hidden This setting disables Top Domains Top Ads Level 2 - hide domains and clients Show and store all domains as hidden and clients as 0.0.0.0 This setting disables Top Domains Top Ads Top Clients Clients over time Level 3 - anonymous mode (anonymize everything) Disable all details except the most anonymous statistics This setting disables Top Domains Top Ads Top Clients Clients over time Query Log Long-term database logging Level 4 - disabled statistics Disables all statistics processing. Even the query counters will not be available. Additionally, you can disable logging to the file /var/log/pihole.log using sudo pihole logging off .","title":"Privacy levels"},{"location":"ftldns/privacylevels/#level-0-show-everything","text":"Doesn't hide anything, all statistics are available","title":"Level 0 - show everything"},{"location":"ftldns/privacylevels/#level-1-hide-domains","text":"Show and store all domains as hidden This setting disables Top Domains Top Ads","title":"Level 1 - hide domains"},{"location":"ftldns/privacylevels/#level-2-hide-domains-and-clients","text":"Show and store all domains as hidden and clients as 0.0.0.0 This setting disables Top Domains Top Ads Top Clients Clients over time","title":"Level 2 - hide domains and clients"},{"location":"ftldns/privacylevels/#level-3-anonymous-mode-anonymize-everything","text":"Disable all details except the most anonymous statistics This setting disables Top Domains Top Ads Top Clients Clients over time Query Log Long-term database logging","title":"Level 3 - anonymous mode (anonymize everything)"},{"location":"ftldns/privacylevels/#level-4-disabled-statistics","text":"Disables all statistics processing. Even the query counters will not be available. Additionally, you can disable logging to the file /var/log/pihole.log using sudo pihole logging off .","title":"Level 4 - disabled statistics"},{"location":"ftldns/telnet-api/","text":"Connect via e.g. telnet 127.0.0.1 4711 or use echo \" command\" | nc 127.0.0.1 4711 quit : Closes connection to client kill : Terminates FTL stats : Get current statistics domains_being_blocked 116007 dns_queries_today 30163 ads_blocked_today 5650 ads_percentage_today 18.731558 unique_domains 1056 queries_forwarded 4275 queries_cached 20238 clients_ever_seen 11 unique_clients 9 status enabled overTime : over time data (10 min intervals) 1525546500 163 0 1525547100 154 1 1525547700 164 0 1525548300 167 0 1525548900 151 0 1525549500 143 0 [...] top-domains : get top domains 0 8462 x.y.z.de 1 236 safebrowsing-cache.google.com 2 116 pi.hole 3 109 z.y.x.de 4 93 safebrowsing.google.com 5 96 plus.google.com [...] Variant: top-domains (15) to show (up to) 15 entries top-ads : get top ad domains 0 8 googleads.g.doubleclick.net 1 6 www.googleadservices.com 2 1 cdn.mxpnl.com 3 1 collector.githubapp.com 4 1 www.googletagmanager.com 5 1 s.zkcdn.net [...] Variant: top-ads (14) to show (up to) 14 entries top-clients : get recently active top clients ( IP addresses + host names (if available)) 0 9373 192.168.2.1 router 1 484 192.168.2.2 work-machine 2 8 127.0.0.1 localhost Variant: top-clients (9) to show (up to) 9 client entries or top-clients withzero (15) to show (up to) 15 clients even if they have not been active recently (see PR #124 for further details) forward-dest : get forward destinations ( IP addresses + host names (if available)) along with the percentage. The first result ( ID -2) will always be the percentage of domains answered from blocklists, whereas the second result ( ID -1) will be the queries answered from cache -2 18.70 blocklist blocklist -1 67.10 cache cache 0 14.20 127.0.0.1 localhost Variant: forward-dest unsorted to show forward destinations in unsorted order (equivalent to using forward-names ) querytypes : get collected query types percentage A (IPv4): 53.45 AAAA (IPv6): 45.32 ANY: 0.00 SRV: 0.64 SOA: 0.05 PTR: 0.54 TXT: 0.00 getallqueries : get all queries that FTL has in memory 1525554586 A fonts.googleapis.com 192.168.2.100 3 0 4 6 1525554586 AAAA fonts.googleapis.com 192.168.2.100 3 0 4 5 1525554586 A www.mkdocs.org 192.168.2.100 3 0 4 7 1525554586 AAAA www.mkdocs.org 192.168.2.100 2 0 3 21 1525554586 A squidfunk.github.io 192.168.2.100 2 0 3 20 1525554586 A pi-hole.net 192.168.2.100 3 0 4 5 1525554586 AAAA squidfunk.github.io 192.168.2.100 3 0 1 6 1525554586 AAAA pi-hole.net 192.168.2.100 2 0 1 18 1525554586 A github.com 192.168.2.100 3 0 4 5 1525554586 AAAA github.com 192.168.2.100 2 0 1 18 Variants: getallqueries (37) show (up to) 37 latest entries, getallqueries-time 1483964295 1483964312 gets all queries that FTL has in its database in a limited time interval, getallqueries-time 1483964295 1483964312 (17) show matches in the (up to) 17 latest entries, getallqueries-domain www.google.com gets all queries that FTL has in its database for a specific domain name, getallqueries-client 2.3.4.5 : gets all queries that FTL has in its database for a specific client name or IP recentBlocked : get most recently pi-holed domain name www.googleadservices.com Variant: recentBlocked (4) show the four most recent blocked domains memory : get information about FTL 's memory usage due to its internal data structure memory allocated for internal data structure: 2944708 bytes (2.94 MB) dynamically allocated allocated memory used for strings: 23963 bytes (23.96 KB) Sum: 2968671 bytes (2.97 MB) clientID : Get ID of currently connected client 6 version : Get version information of the currently running FTL instance version v1.6-3-g106498d-dirty tag v1.6 branch master hash 106498d date 2017-03-26 13:10:43 +0200 dbstats : Get some statistics about FTL 's' long-term storage database (this request may take some time for processing in case of a large database file) queries in database: 2700304 database filesize: 199.20 MB SQLite version: 3.23.1 domain pi-hole.net : Get detailed information about domain (if available) Domain pi-hole.net , ID: 254 Total: 179 Blocked: 0 Wildcard blocked: false cacheinfo : Get DNS server cache size and usage information cache-size: 500000 cache-live-freed: 0 cache-inserted: 15529","title":"Telnet API"},{"location":"ftldns/regex/overview/","text":"A regular expression, or RegEx for short, is a pattern that can be used for building arbitrarily complex blocking rules in FTL DNS . We implement the POSIX Extended Regular Expressions similar to the one used by the UNIX egrep (or grep -E ) command. Our implementation is light and fast as each domain is only checked once for a match (if you query google.com , it will be checked against your RegEx . Any subsequent query to the same domain will not be checked again until you restart pihole-FTL ). How to use regular expressions for blocking FTL DNS reads in regular expression filters from /etc/pihole/regex.list (one expression per line, lines starting with # will be skipped). To tell FTL DNS to reload the list, either: Execute the recompile-regex API command ( echo \" recompile-regex\" | nc localhost 4711 ) or Send SIGHUP to pihole-FTL ( sudo killall -SIGHUP pihole-FTL ) or Restart the service ( sudo service pihole-FTL restart ) Pi-hole Regex debugging mode To ease the usage of regular expression filters in FTL DNS , we offer a regex debugging mode. Set REGEX_DEBUGMODE=true in your /etc/pihole/pihole-FTL.conf and restart pihole-FTL to enable or disable this mode. Once the debugging mode is enabled, each match will be logged to /var/log/pihole-FTL.log in the following format: [2018-07-17 17:40:51.304] DEBUG: Regex in line 2 ((^)|(\\.))twitter\\. matches whatever.twitter.com The given line number corresponds to the line in the file /etc/pihole/regex.list . Note that validation is only done on the first occurrence of a domain to increase the computational efficiency of FTL DNS .","title":"Overview"},{"location":"ftldns/regex/overview/#how-to-use-regular-expressions-for-blocking","text":"FTL DNS reads in regular expression filters from /etc/pihole/regex.list (one expression per line, lines starting with # will be skipped). To tell FTL DNS to reload the list, either: Execute the recompile-regex API command ( echo \" recompile-regex\" | nc localhost 4711 ) or Send SIGHUP to pihole-FTL ( sudo killall -SIGHUP pihole-FTL ) or Restart the service ( sudo service pihole-FTL restart )","title":"How to use regular expressions for blocking"},{"location":"ftldns/regex/overview/#pi-hole-regex-debugging-mode","text":"To ease the usage of regular expression filters in FTL DNS , we offer a regex debugging mode. Set REGEX_DEBUGMODE=true in your /etc/pihole/pihole-FTL.conf and restart pihole-FTL to enable or disable this mode. Once the debugging mode is enabled, each match will be logged to /var/log/pihole-FTL.log in the following format: [2018-07-17 17:40:51.304] DEBUG: Regex in line 2 ((^)|(\\.))twitter\\. matches whatever.twitter.com The given line number corresponds to the line in the file /etc/pihole/regex.list . Note that validation is only done on the first occurrence of a domain to increase the computational efficiency of FTL DNS .","title":"Pi-hole Regex debugging mode"},{"location":"ftldns/regex/tutorial/","text":"Pi-hole regular expressions tutorial We provide a short but thorough introduction to our regular expressions implementation. This may come in handy if you are designing blocking rules (see also our cheat sheet below!). In our implementation, all characters match themselves except for the following special characters: .[{}()\\*+?|^$ . If you want to match those, you need to escape them like \\. for a literal period, but no rule without exception (see character groups below for further details). Anchors ( ^ and $ ) First of all, we look at anchors which can be used to indicate the start or the end of a domain, respectively. If you don't specify anchors, the match may be partial (see examples below). Example Interpretation domain partial match . Without anchors, a text may appear anywhere in the domain. This matches some.domain.com , domain.com and verylongdomain.com and more ^localhost$ exact match matching only localhost but neither a.localhost nor localhost.com ^abc matches any domain starting ( ^ ) in \"abc\" like abcdomain.com , abc.domain.com but not def.abc.com com$ matches any domain ending ( $ ) in \"com\" such as domain.com but not domain.com.co.uk Wildcard ( . ) An unescaped period stands for any single character. Example Interpretation ^domain.$ matches domaina , domainb , domainc , but not domain Bounds and multipliers ( {} , * , + , and ? ) With bounds, one can denote the number of times something has to occur: Bound Meaning ab{4} matches a domain that contains a single a followed by four b (matching only abbbb ) ab{4,} matches a domain that contains a single a followed by at least four b (matching also abbbbbbbb ) ab{3,5} matches a domain that contains a single a followed by three to five b (matching only abbb , abbbb , and abbbbb ) Multipliers are shortcuts for some of the bounds that are needed most often: Multipliers Bounds equivalent Meaning ? {0,1} never or once (optional) * {0,} never or more (optional) + {1,} once or more (mandatory) To illustrate the usefulness of multipliers (and bounds), we provide a few examples: Example Interpretation ^r-*movie matches a domain like r------movie.com where the number of dashes can be arbitrary (also none) ^r-?movie matches only the domains rmovie.com and r-movie.com but not those with more than one dash ^r-+movie matches only the domains with at least one dash, i.e., not rmovie.com ^a?b+ matches domains like abbbb.com (zero or one a at the beginning followed by one or more b ) Character groups ( [] ) With character groups, a set of characters can be matched: Character group Interpretation [abc] matches a , b , or c (using explicitly specified characters) [a-c] matches a , b , or c (using a range ) [a-c]+ matches any non-zero number of a , b , c [a-z] matches any single lowercase letter [a-zA-Z] matches any single letter [a-z0-9] matches any single lowercase letter or any single digit [^a-z] Negation matching any single character except lowercase letters abc[0-9]+ matches the string abc followed by a number of arbitrary length Bracket expressions are an exception to the character escape rule. Inside them, all special characters, including the backslash ( \\ ), lose their special powers, i.e. they match themselves exactly. Furthermore, to include a literal ] in the list, make it the first character (like []] or [^]] if negated). To include a literal - , make it the first or last character, or the second endpoint of a range (e.g. [a-z-] to match a to z and - ). Groups ( () ) Using groups, we can enclose regular expressions, they are most powerful when combined with bounds or multipliers (see also alternations below). Example Interpretation (abc) matches abc (trivial example) (abc)* matches zero or more copies of abc like abcabc but not abcdefabc (abc){1,3} matches one, two or three copies of abc : abc , abcabc , abcabcabc but nothing else Alternations ( | ) Alternations can be used as an \"or\" operator in regular expressions. Example Interpretation (abc)|(def) matches abc and def domain(a|b)\\.com matches domaina.com and domainb.com but not domain.com or domainx.com domain(a|b)*\\.com matches domain.com , domainaaaa.com domainbbb.com but not domainab.com (any number of a or b in between domain and .com ) Character classes ( [:class:] ) In addition to character groups, there are also some special character classes available, such as Character class Group equivalent Interpretation [:digit:] [0-9] matches digits [:lower:] [a-z] matched lowercase letters [:upper:] [A-Z] matched uppercase letters [:alpha:] [A-Za-z] matches alphabetic characters [:alnum:] [A-Za-z0-9] matches alphabetic characters and digits Advanced examples After going through our quick tutorial, we provide some more advances examples so you can test your knowledge. Block domain with only numbers ^[0-9][^a-z]+\\.((com)|(edu))$ Blocks domains containing only numbers (no letters) and ending in .com or .edu . Blocks 555661.com , and 456.edu , but not 555g555.com Block domains without subdomains ^[a-z0-9]+([\\-]{1}[a-z0-9]+)*\\.[a-z]{2,7}$ A domain name shall not start or end with a dash but can contain any number of them. It must be followed by a TLD (we assume a valid TLD length of two to seven characters) Cheatsheet Expression Meaning Example ^ Beginning of string ^client matches strings that begin with client , such as client.server.com but not more.client.server.com (exception: within a character range ( [] ) ^ means negation) $ End of string ing$ matches exciting but not ingenious * Match zero or more of the previous ah* matches ahhhhh or a ? Match zero or one of the previous ah? matches a or ah + Match one or more of the previous ah+ matches ah or ahhh but not a . Wildcard character, matches any character do.* matches do , dog , door , dot , etc.; do.+ matches dog , door , dot , etc. but not do (wildcard with + requires at least one extra character for matching) ( ) Group Enclose regular expressions, see the example for | | Alternation (mon|tues)day matches monday or tuesday but not friday or mondiag [ ] Matches a range of characters [cbf]ar matches car , bar , or far ; [^] Negation [^0-9] matches any character except 0 to 9 { } Matches a specified number of occurrences of the previous [0-9]{3} matches any three-digit number like 315 but not 31 ; [0-9]{2,4} matches two- to four-digit numbers like 12 , 123 , and 1234 but not 1 or 12345 ; [0-9]{2,} matches any number with two or more digits like 1234567 , 123456789 , but not 1 \\ Used to escape a special character not inside [] google\\.com matches google.com","title":"Tutorial"},{"location":"ftldns/regex/tutorial/#pi-hole-regular-expressions-tutorial","text":"We provide a short but thorough introduction to our regular expressions implementation. This may come in handy if you are designing blocking rules (see also our cheat sheet below!). In our implementation, all characters match themselves except for the following special characters: .[{}()\\*+?|^$ . If you want to match those, you need to escape them like \\. for a literal period, but no rule without exception (see character groups below for further details).","title":"Pi-hole regular expressions tutorial"},{"location":"ftldns/regex/tutorial/#anchors-and","text":"First of all, we look at anchors which can be used to indicate the start or the end of a domain, respectively. If you don't specify anchors, the match may be partial (see examples below). Example Interpretation domain partial match . Without anchors, a text may appear anywhere in the domain. This matches some.domain.com , domain.com and verylongdomain.com and more ^localhost$ exact match matching only localhost but neither a.localhost nor localhost.com ^abc matches any domain starting ( ^ ) in \"abc\" like abcdomain.com , abc.domain.com but not def.abc.com com$ matches any domain ending ( $ ) in \"com\" such as domain.com but not domain.com.co.uk","title":"Anchors (^ and $)"},{"location":"ftldns/regex/tutorial/#wildcard","text":"An unescaped period stands for any single character. Example Interpretation ^domain.$ matches domaina , domainb , domainc , but not domain","title":"Wildcard (.)"},{"location":"ftldns/regex/tutorial/#bounds-and-multipliers-and","text":"With bounds, one can denote the number of times something has to occur: Bound Meaning ab{4} matches a domain that contains a single a followed by four b (matching only abbbb ) ab{4,} matches a domain that contains a single a followed by at least four b (matching also abbbbbbbb ) ab{3,5} matches a domain that contains a single a followed by three to five b (matching only abbb , abbbb , and abbbbb ) Multipliers are shortcuts for some of the bounds that are needed most often: Multipliers Bounds equivalent Meaning ? {0,1} never or once (optional) * {0,} never or more (optional) + {1,} once or more (mandatory) To illustrate the usefulness of multipliers (and bounds), we provide a few examples: Example Interpretation ^r-*movie matches a domain like r------movie.com where the number of dashes can be arbitrary (also none) ^r-?movie matches only the domains rmovie.com and r-movie.com but not those with more than one dash ^r-+movie matches only the domains with at least one dash, i.e., not rmovie.com ^a?b+ matches domains like abbbb.com (zero or one a at the beginning followed by one or more b )","title":"Bounds and multipliers ({}, *, +, and ?)"},{"location":"ftldns/regex/tutorial/#character-groups","text":"With character groups, a set of characters can be matched: Character group Interpretation [abc] matches a , b , or c (using explicitly specified characters) [a-c] matches a , b , or c (using a range ) [a-c]+ matches any non-zero number of a , b , c [a-z] matches any single lowercase letter [a-zA-Z] matches any single letter [a-z0-9] matches any single lowercase letter or any single digit [^a-z] Negation matching any single character except lowercase letters abc[0-9]+ matches the string abc followed by a number of arbitrary length Bracket expressions are an exception to the character escape rule. Inside them, all special characters, including the backslash ( \\ ), lose their special powers, i.e. they match themselves exactly. Furthermore, to include a literal ] in the list, make it the first character (like []] or [^]] if negated). To include a literal - , make it the first or last character, or the second endpoint of a range (e.g. [a-z-] to match a to z and - ).","title":"Character groups ([])"},{"location":"ftldns/regex/tutorial/#groups","text":"Using groups, we can enclose regular expressions, they are most powerful when combined with bounds or multipliers (see also alternations below). Example Interpretation (abc) matches abc (trivial example) (abc)* matches zero or more copies of abc like abcabc but not abcdefabc (abc){1,3} matches one, two or three copies of abc : abc , abcabc , abcabcabc but nothing else","title":"Groups (())"},{"location":"ftldns/regex/tutorial/#alternations","text":"Alternations can be used as an \"or\" operator in regular expressions. Example Interpretation (abc)|(def) matches abc and def domain(a|b)\\.com matches domaina.com and domainb.com but not domain.com or domainx.com domain(a|b)*\\.com matches domain.com , domainaaaa.com domainbbb.com but not domainab.com (any number of a or b in between domain and .com )","title":"Alternations (|)"},{"location":"ftldns/regex/tutorial/#character-classes-class","text":"In addition to character groups, there are also some special character classes available, such as Character class Group equivalent Interpretation [:digit:] [0-9] matches digits [:lower:] [a-z] matched lowercase letters [:upper:] [A-Z] matched uppercase letters [:alpha:] [A-Za-z] matches alphabetic characters [:alnum:] [A-Za-z0-9] matches alphabetic characters and digits","title":"Character classes ([:class:])"},{"location":"ftldns/regex/tutorial/#advanced-examples","text":"After going through our quick tutorial, we provide some more advances examples so you can test your knowledge.","title":"Advanced examples"},{"location":"ftldns/regex/tutorial/#block-domain-with-only-numbers","text":"^[0-9][^a-z]+\\.((com)|(edu))$ Blocks domains containing only numbers (no letters) and ending in .com or .edu . Blocks 555661.com , and 456.edu , but not 555g555.com","title":"Block domain with only numbers"},{"location":"ftldns/regex/tutorial/#block-domains-without-subdomains","text":"^[a-z0-9]+([\\-]{1}[a-z0-9]+)*\\.[a-z]{2,7}$ A domain name shall not start or end with a dash but can contain any number of them. It must be followed by a TLD (we assume a valid TLD length of two to seven characters)","title":"Block domains without subdomains"},{"location":"ftldns/regex/tutorial/#cheatsheet","text":"Expression Meaning Example ^ Beginning of string ^client matches strings that begin with client , such as client.server.com but not more.client.server.com (exception: within a character range ( [] ) ^ means negation) $ End of string ing$ matches exciting but not ingenious * Match zero or more of the previous ah* matches ahhhhh or a ? Match zero or one of the previous ah? matches a or ah + Match one or more of the previous ah+ matches ah or ahhh but not a . Wildcard character, matches any character do.* matches do , dog , door , dot , etc.; do.+ matches dog , door , dot , etc. but not do (wildcard with + requires at least one extra character for matching) ( ) Group Enclose regular expressions, see the example for | | Alternation (mon|tues)day matches monday or tuesday but not friday or mondiag [ ] Matches a range of characters [cbf]ar matches car , bar , or far ; [^] Negation [^0-9] matches any character except 0 to 9 { } Matches a specified number of occurrences of the previous [0-9]{3} matches any three-digit number like 315 but not 31 ; [0-9]{2,4} matches two- to four-digit numbers like 12 , 123 , and 1234 but not 1 or 12345 ; [0-9]{2,} matches any number with two or more digits like 1234567 , 123456789 , but not 1 \\ Used to escape a special character not inside [] google\\.com matches google.com","title":"Cheatsheet"},{"location":"guides/dns-over-https/","text":"Why use DNS-Over-HTTPS? DNS-Over-HTTPS is a protocol for performing DNS lookups via the same protocol you use to browse the web securely: HTTPS . With standard DNS, requests are sent in plain-text, with no method to detect tampering or misbehaviour. This means that not only can a malicous actor look at all the DNS requests you are making (and therefore what websites you are visiting), they can also tamper with the response and redirect your device to resources in their control (such as a fake login page for internet banking). DNS-Over-HTTPS prevents this by using standard HTTPS requests to retrieve DNS information. This means that the connection from the device to the DNS server is secure and can not easily be snooped, monitored, tampered with or blocked. It is worth noting however, that the upstream DNS-Over-HTTPS provider will still have this ability. Configuring DNS-Over-HTTPS Along with releasing their DNS service 1.1.1.1 , Cloudflare implemented DNS-Over-HTTPS proxy functionality in to one of their tools: cloudflared . In the following sections we will be covering how to install and configure this tool on Pi-hole . Installing cloudflared The installation is fairly straightforward, however be aware of what architecture you are installing on ( amd64 or arm ). AMD64 architecture (most devices) Download the installer package, then use apt-get to install the package along with any dependencies. Proceed to run the binary with the -v flag to check it is all working. wget https://bin.equinox.io/c/VdrWdbjqyF/cloudflared-stable-linux-amd64.deb sudo apt-get install ./cloudflared-stable-linux-amd64.deb cloudflared -v ARM architecture (Raspberry Pi) Here we are downloading the precompiled binary and copying it to the /usr/local/bin/ directory to allow execution by the cloudflared user. Proceed to run the binary with the -v flag to check it is all working. wget https://bin.equinox.io/c/VdrWdbjqyF/cloudflared-stable-linux-arm.tgz tar -xvzf cloudflared-stable-linux-arm.tgz cp ./cloudflared /usr/local/bin chmod +x /usr/local/bin/cloudflared cloudflared -v Configuring cloudflared to run on startup Create a cloudflared user to run the daemon. sudo useradd -s /usr/sbin/nologin -r -M cloudflared Proceed to create a configuration file for cloudflared by copying the following in to /etc/default/cloudflared . This file contains the command-line options that get passed to cloudflared on startup. # Commandline args for cloudflared CLOUDFLARED_OPTS=--port 5053 --upstream https://1.1.1.1/dns-query --upstream https://1.0.0.1/dns-query Update the permissions for the configuration file and cloudflared binary to allow access for the cloudflared user sudo chown cloudflared:cloudflared /etc/default/cloudflared sudo chown cloudflared:cloudflared /usr/local/bin/cloudflared Then create the systemd script by copying the following in to /lib/systemd/system/cloudflared.service . This will control the running of the service and allow it to run on startup. [Unit] Description = cloudflared DNS over HTTPS proxy After = syslog.target network-online.target [Service] Type = simple User = cloudflared EnvironmentFile = /etc/default/cloudflared ExecStart = /usr/local/bin/cloudflared proxy-dns $CLOUDFLARED_OPTS Restart = on-failure RestartSec = 10 KillMode = process [Install] WantedBy = multi-user.target Enable the systemd service to run on startup, then start the service and check its status. sudo systemctl enable cloudflared sudo systemctl start cloudflared sudo systemctl status cloudflared Now test that it is working! Run the following dig command, a response should be returned similar to the one below dig @127.0.0.1 - p 5053 google . com ; DiG 9.10.3 - P4 - Ubuntu @127.0.0.1 - p 5053 google . com ; ( 1 server found ) ;; global options : + cmd ;; Got answer : ;; - HEADER - opcode : QUERY , status : NOERROR , id : 65181 ;; flags : qr rd ra ; QUERY : 1 , ANSWER : 1 , AUTHORITY : 0 , ADDITIONAL : 1 ;; OPT PSEUDOSECTION : ; EDNS : version : 0 , flags :; udp : 1536 ;; QUESTION SECTION : ; google . com . IN A ;; ANSWER SECTION : google . com . 299 IN A 243.65.127.221 ;; Query time : 3 msec ;; SERVER : 127.0.0.1 # 5053 ( 127.0.0.1 ) ;; MSG SIZE rcvd : 65 Configuring Pi-hole Finally, configure Pi-hole to use the local cloudflared service as the upstream DNS server: (don't forget to hit Return or click on Save ) Based on this guide by Ben Dews | bendews.com","title":"Configuring DNS-Over-HTTPS on Pi-hole"},{"location":"guides/dns-over-https/#why-use-dns-over-https","text":"DNS-Over-HTTPS is a protocol for performing DNS lookups via the same protocol you use to browse the web securely: HTTPS . With standard DNS, requests are sent in plain-text, with no method to detect tampering or misbehaviour. This means that not only can a malicous actor look at all the DNS requests you are making (and therefore what websites you are visiting), they can also tamper with the response and redirect your device to resources in their control (such as a fake login page for internet banking). DNS-Over-HTTPS prevents this by using standard HTTPS requests to retrieve DNS information. This means that the connection from the device to the DNS server is secure and can not easily be snooped, monitored, tampered with or blocked. It is worth noting however, that the upstream DNS-Over-HTTPS provider will still have this ability.","title":"Why use DNS-Over-HTTPS?"},{"location":"guides/dns-over-https/#configuring-dns-over-https","text":"Along with releasing their DNS service 1.1.1.1 , Cloudflare implemented DNS-Over-HTTPS proxy functionality in to one of their tools: cloudflared . In the following sections we will be covering how to install and configure this tool on Pi-hole .","title":"Configuring DNS-Over-HTTPS"},{"location":"guides/dns-over-https/#installing-cloudflared","text":"The installation is fairly straightforward, however be aware of what architecture you are installing on ( amd64 or arm ).","title":"Installing cloudflared"},{"location":"guides/dns-over-https/#amd64-architecture-most-devices","text":"Download the installer package, then use apt-get to install the package along with any dependencies. Proceed to run the binary with the -v flag to check it is all working. wget https://bin.equinox.io/c/VdrWdbjqyF/cloudflared-stable-linux-amd64.deb sudo apt-get install ./cloudflared-stable-linux-amd64.deb cloudflared -v","title":"AMD64 architecture (most devices)"},{"location":"guides/dns-over-https/#arm-architecture-raspberry-pi","text":"Here we are downloading the precompiled binary and copying it to the /usr/local/bin/ directory to allow execution by the cloudflared user. Proceed to run the binary with the -v flag to check it is all working. wget https://bin.equinox.io/c/VdrWdbjqyF/cloudflared-stable-linux-arm.tgz tar -xvzf cloudflared-stable-linux-arm.tgz cp ./cloudflared /usr/local/bin chmod +x /usr/local/bin/cloudflared cloudflared -v","title":"ARM architecture (Raspberry Pi)"},{"location":"guides/dns-over-https/#configuring-cloudflared-to-run-on-startup","text":"Create a cloudflared user to run the daemon. sudo useradd -s /usr/sbin/nologin -r -M cloudflared Proceed to create a configuration file for cloudflared by copying the following in to /etc/default/cloudflared . This file contains the command-line options that get passed to cloudflared on startup. # Commandline args for cloudflared CLOUDFLARED_OPTS=--port 5053 --upstream https://1.1.1.1/dns-query --upstream https://1.0.0.1/dns-query Update the permissions for the configuration file and cloudflared binary to allow access for the cloudflared user sudo chown cloudflared:cloudflared /etc/default/cloudflared sudo chown cloudflared:cloudflared /usr/local/bin/cloudflared Then create the systemd script by copying the following in to /lib/systemd/system/cloudflared.service . This will control the running of the service and allow it to run on startup. [Unit] Description = cloudflared DNS over HTTPS proxy After = syslog.target network-online.target [Service] Type = simple User = cloudflared EnvironmentFile = /etc/default/cloudflared ExecStart = /usr/local/bin/cloudflared proxy-dns $CLOUDFLARED_OPTS Restart = on-failure RestartSec = 10 KillMode = process [Install] WantedBy = multi-user.target Enable the systemd service to run on startup, then start the service and check its status. sudo systemctl enable cloudflared sudo systemctl start cloudflared sudo systemctl status cloudflared Now test that it is working! Run the following dig command, a response should be returned similar to the one below dig @127.0.0.1 - p 5053 google . com ; DiG 9.10.3 - P4 - Ubuntu @127.0.0.1 - p 5053 google . com ; ( 1 server found ) ;; global options : + cmd ;; Got answer : ;; - HEADER - opcode : QUERY , status : NOERROR , id : 65181 ;; flags : qr rd ra ; QUERY : 1 , ANSWER : 1 , AUTHORITY : 0 , ADDITIONAL : 1 ;; OPT PSEUDOSECTION : ; EDNS : version : 0 , flags :; udp : 1536 ;; QUESTION SECTION : ; google . com . IN A ;; ANSWER SECTION : google . com . 299 IN A 243.65.127.221 ;; Query time : 3 msec ;; SERVER : 127.0.0.1 # 5053 ( 127.0.0.1 ) ;; MSG SIZE rcvd : 65","title":"Configuring cloudflared to run on startup"},{"location":"guides/dns-over-https/#configuring-pi-hole","text":"Finally, configure Pi-hole to use the local cloudflared service as the upstream DNS server: (don't forget to hit Return or click on Save ) Based on this guide by Ben Dews | bendews.com","title":"Configuring Pi-hole"},{"location":"guides/unbound/","text":"The problem: Whom can you trust? Pi-hole includes a caching and forwarding DNS server, now known as FTL DNS. After applying the blocking lists, it forwards requests made by the clients to configured upstream DNS server(s). However, as has been mentioned by several users in the past, this leads to some privacy concerns as it ultimately raises the question: Whom can you trust? Recently, more and more small (and not so small) DNS upstream providers have appeared on the market, advertising free and private DNS service, but how can you know that they keep their promises? Right, you can't. Furthermore, from the point of an attacker, the DNS servers of larger providers are very worthwhile targets, as they only need to poison one DNS server, but millions of users might be affected. Instead of your bank's actual IP address, you could be sent to a phishing site hosted on some island. This scenario has already happened and it isn't unlikely to happen again... When you operate your own (tiny) recursive DNS server, then the likeliness of getting affected by such an attack is greatly reduced. What is a recursive DNS server? The first distinction we have to be aware of is whether a DNS server is authoritative or not. If I'm the authoritative server for, e.g., pi-hole.net , then I know which IP is the correct answer for a query. Recursive name servers, in contrast, resolve any query they receive by consulting the servers authoritative for this query by traversing the domain. Example: We want to resolve pi-hole.net . On behalf of the client, the recursive DNS server will traverse the path of the domain across the Internet to deliver the answer to the question. What does this guide provide? In only a few simple steps, we will describe how to set up your own recursive DNS server. It will run on the same device you're already using for your Pi-hole. There are no additional hardware requirements. This guide assumes a fairly recent Debian/Ubuntu based system and will use the maintainer provided packages for installation to make it an incredibly simple process. It assumes only very basic knowledge of how DNS works. A standard Pi-hole installation will do it as follows: Your client asks the Pi-hole Who is pi-hole.net ? Your Pi-hole will check its cache and reply if the answer is already known. Your Pi-hole will check the blocking lists and reply if the domain is blocked. Since neither 2. nor 3. is true in our example, the Pi-hole forwards the request to the configured external upstream DNS server(s). Upon receiving the answer, your Pi-hole will reply to your client and tell it the answer of its request. Lastly, your Pi-hole will save the answer in its cache to be able to respond faster if any of your clients queries the same domain again. After you set up your Pi-hole as described in this guide, this procedure changes notably: Your client asks the Pi-hole Who is pi-hole.net ? Your Pi-hole will check its cache and reply if the answer is already known. Your Pi-hole will check the blocking lists and reply if the domain is blocked. Since neither 2. nor 3. is true in our example, the Pi-hole delegates the request to the (local) recursive DNS resolver. Your recursive server will send a query to the DNS root servers: \"Who is handling .net ?\" The root server answers with a referral to the TLD servers for .net . Your recursive server will send a query to one of the TLD DNS servers for .net : \"Who is handling pi-hole.net ?\" The TLD server answers with a referral to the authoritative name servers for pi-hole.net . Your recursive server will send a query to the authoritative name servers: \"What is the IP of pi-hole.net ?\" The authoritative server will answer with the IP address of the domain pi-hole.net . Your recursive server will send the reply to your Pi-hole which will, in turn, reply to your client and tell it the answer of its request. Lastly, your Pi-hole will save the answer in its cache to be able to respond faster if any of your clients queries the same domain again. You can easily imagine even longer chains for subdomains as the query process continues until your recursive resolver reaches the authoritative server for the zone that contains the queried domain name. It is obvious that the methods are very different and the own recursion is more involved than \"just\" asking some upstream server. This has benefits and drawbacks: Benefit: Privacy - as you're directly contacting the responsive servers, no server can fully log the exact paths you're going, as e.g. the Google DNS servers will only be asked if you want to visit a Google website, but not if you visit the website of your favorite newspaper, etc. Drawback: Traversing the path may be slow, especially for the first time you visit a website - while the bigger DNS providers always have answers for commonly used domains in their cache, you will have to transverse the path if you visit a page for the first time time. A first request to a formerly unknown TLD may take up to a second (or even more if you're also using DNSSEC). Subsequent requests to domains under the same TLD usually complete in 0.1s . Fortunately, both your Pi-hole as well as your recursive server will be configured for efficient caching to minimize the number of queries that will actually have to be performed. Setting up Pi-hole as a recursive DNS server solution We will use unbound , a secure open source recursive DNS server primarily developed by NLnet Labs, VeriSign Inc., Nominet, and Kirei. The first thing you need to do is to install the recursive DNS resolver: sudo apt install unbound Optional: Download the list of primary root servers (serving the domain . ). Unbound ships its own list but we can also download the most recent list and update it whenever we think it is a good idea. Note: there is no point in doing it more often then every 6 months. wget -O root.hints https://www.internic.net/domain/named.root sudo mv root.hints /var/lib/unbound/ Configure unbound Highlights: - Listen only for queries from the local Pi-hole installation (on port 5353) - Listen for both UDP and TCP requests - Verify DNSSEC signatures, discarding BOGUS domains - Apply a few security and privacy tricks /etc/unbound/unbound.conf.d/pi-hole.conf : server: logfile: /var/log/unbound/unbound.log verbosity: 0 port: 5353 do-ip4: yes do-udp: yes do-tcp: yes # May be set to yes if you have IPv6 connectivity do-ip6: no # Use this only when you downloaded the list of primary root servers! root-hints: /var/lib/unbound/root.hints # Trust glue only if it is within the servers authority harden-glue: yes # Require DNSSEC data for trust-anchored zones, if such data is absent, the zone becomes BOGUS harden-dnssec-stripped: yes # Don t use Capitalization randomization as it known to cause DNSSEC issues sometimes # see https://discourse.pi-hole.net/t/unbound-stubby-or-dnscrypt-proxy/9378 for further details use-caps-for-id: no # Reduce EDNS reassembly buffer size. # Suggested by the unbound man page to reduce fragmentation reassembly problems edns-buffer-size: 1472 # TTL bounds for cache cache-min-ttl: 3600 cache-max-ttl: 86400 # Perform prefetching of close to expired message cache entries # This only applies to domains that have been frequently queried prefetch: yes # One thread should be sufficient, can be increased on beefy machines num-threads: 1 # Ensure kernel buffer is large enough to not loose messages in traffic spikes so-rcvbuf: 1m # Ensure privacy of local IP ranges private-address: 192.168.0.0/16 private-address: 169.254.0.0/16 private-address: 172.16.0.0/12 private-address: 10.0.0.0/8 private-address: fd00::/8 private-address: fe80::/10 Start your local recursive server and test that it's operational: sudo service unbound start dig pi - hole . net @127.0.0.1 - p 5353 The first query may be quite slow, but subsequent queries, also to other domains under the same TLD, should be fairly quick. Test validation You can test DNSSEC validation using dig sigfail . verteiltesysteme . net @127.0.0.1 - p 5353 dig sigok . verteiltesysteme . net @127.0.0.1 - p 5353 The first command should give a status report of SERVFAIL and no IP address. The second should give NOERROR plus an IP address. Configure Pi-hole Finally, configure Pi-hole to use your recursive DNS server: (don't forget to hit Return or click on Save )","title":"Pi-hole as All-Around DNS Solution"},{"location":"guides/unbound/#the-problem-whom-can-you-trust","text":"Pi-hole includes a caching and forwarding DNS server, now known as FTL DNS. After applying the blocking lists, it forwards requests made by the clients to configured upstream DNS server(s). However, as has been mentioned by several users in the past, this leads to some privacy concerns as it ultimately raises the question: Whom can you trust? Recently, more and more small (and not so small) DNS upstream providers have appeared on the market, advertising free and private DNS service, but how can you know that they keep their promises? Right, you can't. Furthermore, from the point of an attacker, the DNS servers of larger providers are very worthwhile targets, as they only need to poison one DNS server, but millions of users might be affected. Instead of your bank's actual IP address, you could be sent to a phishing site hosted on some island. This scenario has already happened and it isn't unlikely to happen again... When you operate your own (tiny) recursive DNS server, then the likeliness of getting affected by such an attack is greatly reduced.","title":"The problem: Whom can you trust?"},{"location":"guides/unbound/#what-is-a-recursive-dns-server","text":"The first distinction we have to be aware of is whether a DNS server is authoritative or not. If I'm the authoritative server for, e.g., pi-hole.net , then I know which IP is the correct answer for a query. Recursive name servers, in contrast, resolve any query they receive by consulting the servers authoritative for this query by traversing the domain. Example: We want to resolve pi-hole.net . On behalf of the client, the recursive DNS server will traverse the path of the domain across the Internet to deliver the answer to the question.","title":"What is a recursive DNS server?"},{"location":"guides/unbound/#what-does-this-guide-provide","text":"In only a few simple steps, we will describe how to set up your own recursive DNS server. It will run on the same device you're already using for your Pi-hole. There are no additional hardware requirements. This guide assumes a fairly recent Debian/Ubuntu based system and will use the maintainer provided packages for installation to make it an incredibly simple process. It assumes only very basic knowledge of how DNS works. A standard Pi-hole installation will do it as follows: Your client asks the Pi-hole Who is pi-hole.net ? Your Pi-hole will check its cache and reply if the answer is already known. Your Pi-hole will check the blocking lists and reply if the domain is blocked. Since neither 2. nor 3. is true in our example, the Pi-hole forwards the request to the configured external upstream DNS server(s). Upon receiving the answer, your Pi-hole will reply to your client and tell it the answer of its request. Lastly, your Pi-hole will save the answer in its cache to be able to respond faster if any of your clients queries the same domain again. After you set up your Pi-hole as described in this guide, this procedure changes notably: Your client asks the Pi-hole Who is pi-hole.net ? Your Pi-hole will check its cache and reply if the answer is already known. Your Pi-hole will check the blocking lists and reply if the domain is blocked. Since neither 2. nor 3. is true in our example, the Pi-hole delegates the request to the (local) recursive DNS resolver. Your recursive server will send a query to the DNS root servers: \"Who is handling .net ?\" The root server answers with a referral to the TLD servers for .net . Your recursive server will send a query to one of the TLD DNS servers for .net : \"Who is handling pi-hole.net ?\" The TLD server answers with a referral to the authoritative name servers for pi-hole.net . Your recursive server will send a query to the authoritative name servers: \"What is the IP of pi-hole.net ?\" The authoritative server will answer with the IP address of the domain pi-hole.net . Your recursive server will send the reply to your Pi-hole which will, in turn, reply to your client and tell it the answer of its request. Lastly, your Pi-hole will save the answer in its cache to be able to respond faster if any of your clients queries the same domain again. You can easily imagine even longer chains for subdomains as the query process continues until your recursive resolver reaches the authoritative server for the zone that contains the queried domain name. It is obvious that the methods are very different and the own recursion is more involved than \"just\" asking some upstream server. This has benefits and drawbacks: Benefit: Privacy - as you're directly contacting the responsive servers, no server can fully log the exact paths you're going, as e.g. the Google DNS servers will only be asked if you want to visit a Google website, but not if you visit the website of your favorite newspaper, etc. Drawback: Traversing the path may be slow, especially for the first time you visit a website - while the bigger DNS providers always have answers for commonly used domains in their cache, you will have to transverse the path if you visit a page for the first time time. A first request to a formerly unknown TLD may take up to a second (or even more if you're also using DNSSEC). Subsequent requests to domains under the same TLD usually complete in 0.1s . Fortunately, both your Pi-hole as well as your recursive server will be configured for efficient caching to minimize the number of queries that will actually have to be performed.","title":"What does this guide provide?"},{"location":"guides/unbound/#setting-up-pi-hole-as-a-recursive-dns-server-solution","text":"We will use unbound , a secure open source recursive DNS server primarily developed by NLnet Labs, VeriSign Inc., Nominet, and Kirei. The first thing you need to do is to install the recursive DNS resolver: sudo apt install unbound Optional: Download the list of primary root servers (serving the domain . ). Unbound ships its own list but we can also download the most recent list and update it whenever we think it is a good idea. Note: there is no point in doing it more often then every 6 months. wget -O root.hints https://www.internic.net/domain/named.root sudo mv root.hints /var/lib/unbound/","title":"Setting up Pi-hole as a recursive DNS server solution"},{"location":"guides/unbound/#configure-unbound","text":"Highlights: - Listen only for queries from the local Pi-hole installation (on port 5353) - Listen for both UDP and TCP requests - Verify DNSSEC signatures, discarding BOGUS domains - Apply a few security and privacy tricks /etc/unbound/unbound.conf.d/pi-hole.conf : server: logfile: /var/log/unbound/unbound.log verbosity: 0 port: 5353 do-ip4: yes do-udp: yes do-tcp: yes # May be set to yes if you have IPv6 connectivity do-ip6: no # Use this only when you downloaded the list of primary root servers! root-hints: /var/lib/unbound/root.hints # Trust glue only if it is within the servers authority harden-glue: yes # Require DNSSEC data for trust-anchored zones, if such data is absent, the zone becomes BOGUS harden-dnssec-stripped: yes # Don t use Capitalization randomization as it known to cause DNSSEC issues sometimes # see https://discourse.pi-hole.net/t/unbound-stubby-or-dnscrypt-proxy/9378 for further details use-caps-for-id: no # Reduce EDNS reassembly buffer size. # Suggested by the unbound man page to reduce fragmentation reassembly problems edns-buffer-size: 1472 # TTL bounds for cache cache-min-ttl: 3600 cache-max-ttl: 86400 # Perform prefetching of close to expired message cache entries # This only applies to domains that have been frequently queried prefetch: yes # One thread should be sufficient, can be increased on beefy machines num-threads: 1 # Ensure kernel buffer is large enough to not loose messages in traffic spikes so-rcvbuf: 1m # Ensure privacy of local IP ranges private-address: 192.168.0.0/16 private-address: 169.254.0.0/16 private-address: 172.16.0.0/12 private-address: 10.0.0.0/8 private-address: fd00::/8 private-address: fe80::/10 Start your local recursive server and test that it's operational: sudo service unbound start dig pi - hole . net @127.0.0.1 - p 5353 The first query may be quite slow, but subsequent queries, also to other domains under the same TLD, should be fairly quick.","title":"Configure unbound"},{"location":"guides/unbound/#test-validation","text":"You can test DNSSEC validation using dig sigfail . verteiltesysteme . net @127.0.0.1 - p 5353 dig sigok . verteiltesysteme . net @127.0.0.1 - p 5353 The first command should give a status report of SERVFAIL and no IP address. The second should give NOERROR plus an IP address.","title":"Test validation"},{"location":"guides/unbound/#configure-pi-hole","text":"Finally, configure Pi-hole to use your recursive DNS server: (don't forget to hit Return or click on Save )","title":"Configure Pi-hole"},{"location":"guides/vpn/android-client/","text":"Install the official OpenVPN App from the App Store Log into your OpenVPN server and use the road warrior installer to create a new certificate for your device: root@ubuntu-512mb-fra1-01:~# bash openvpn-install.sh Looks like OpenVPN is already installed What do you want to do? 1) Add a cert for a new user 2) Revoke existing user cert 3) Remove OpenVPN 4) Exit Select an option [1-4]: 1 Tell me a name for the client cert Please, use one word only, no special characters Client name: android Generating a 2048 bit RSA private key .....+++ ..................................+++ writing new private key to ... ----- Using configuration from /etc/openvpn/easy-rsa/openssl-1.0.cnf Check that the request matches the signature Signature ok The Subject s Distinguished Name is as follows commonName :ASN.1 12: android Certificate is to be certified until Jan 25 15:07:37 2027 GMT (3650 days) Write out database with 1 new entries Data Base Updated Client android added, configuration is available at /root/android.ovpn Copy the mentioned file ( /root/android.ovpn ) to your Android device (e.g. SD card) and import it in the app: Connect to your OpenVPN server You are ready to go!","title":"Android"},{"location":"guides/vpn/clients/","text":"Create a client config file ( .ovpn ) Now that the server is configured, you'll want to connect some clients so you can make use of your Pi-hole wherever you are. Doing so requires the use of a certificate. You generate these and the resulting .ovpn file by running the installer and choosing 1) Add a new user for each client that will connect to the VPN. You can repeat this process for as many clients as you need. In this example, we'll \"Add a new user\" by naming the .ovpn file the same as the client's hostname but you may want to adopt your own naming strategy. Run the OpenVPN installer again ./openvpn-install.sh Choose 1) Add a new user and enter a client name Looks like OpenVPN is already installed What do you want to do? 1) Add a new user 2) Revoke an existing user 3) Remove OpenVPN 4) Exit Select an option [1-4]: 1 Tell me a name for the client certificate Please, use one word only, no special characters Client name: iphone7 This will generate a .ovpn file, which needs to be copied to your client machine (often times using the OpenVPN app). This process also generates a few other files found in /etc/openvpn/easy-rsa/pki/ , which make public key authentication possible; you only need to worry about the .ovpn file, though. Connect a client using the .ovpn file The OpenVPN documentation has some decent guides on connecting desktop clients for Mac, Windows, and Linux , so we'll instead explain how to connect a mobile device, since that provides the most usefulness in today's world-- connecting to your ad-blocking VPN via a mobile device . We'll go through two examples: connect an iPhone using the OpenVPN Connect mobile app (see here for Android) connect a Linux machine iOS First make sure the OpenVPN connect app is installed on your phone or mobile device. Import the .ovpn file into iOS. There are several ways to do this, but be careful about transferring it over an insecure medium. Airdrop the file from another device Store the file in a cloud app and open it ion your device Message the file to yourself (not recommended) Email the file to yourself (not recommended) WARNING Anyone who gets his hands on this configuration/certificate file can obtain full access to your VPN. Make sure that you use only trusted paths for transferring the file (e.g. never send it via an un-encrypted channel, e.g. email or FTP). Best strategy is to use an USB thumb drive to avoid any network transport at all (when possible). Make sure to delete the certificate on the USB drive afterwards. NOTICE If one of your certificates has been compromised, remove it using option 2 when you run the installer and generate a new certificate. This will effectively lock out anyone who might have gotten access to the certificate. Once you get it on your device, you can open the file in the OpenVPN app. Click the green plus to add the profile to your phone. You can connect from within the app or you can connect from the Settings app once you grant it access to do so. Linux We'll demonstrate the procedure here for Ubuntu Linux (which trivially extends to Linux Mint, etc.) Install the necessary network-manager plugins sudo apt-get install network-manager-openvpn network-manager-openvpn-gnome sudo service network-manager restart Securely copy the necessary certificates from your OpenVPN server to your client (e.g. using sftp ). They are located in /etc/openvpn/easy-rsa/pki You will need: User Certificate: /etc/openvpn/easy-rsa/pki/issued/client.crt CA Certificate: /etc/openvpn/easy-rsa/pki/ca.crt Private Key: /etc/openvpn/easy-rsa/pki/private/client.key Private Key Password: Depending on your settings (might even be empty) TA Key: /etc/openvpn/ta.key Further details can be found in the screenshots provided below: Your whole network traffic will now securely be transferred to your Pi-hole. Windows You will have to install additional software. See https://openvpn.net/index.php/open-source/downloads.html","title":"General"},{"location":"guides/vpn/clients/#create-a-client-config-file-ovpn","text":"Now that the server is configured, you'll want to connect some clients so you can make use of your Pi-hole wherever you are. Doing so requires the use of a certificate. You generate these and the resulting .ovpn file by running the installer and choosing 1) Add a new user for each client that will connect to the VPN. You can repeat this process for as many clients as you need. In this example, we'll \"Add a new user\" by naming the .ovpn file the same as the client's hostname but you may want to adopt your own naming strategy. Run the OpenVPN installer again ./openvpn-install.sh Choose 1) Add a new user and enter a client name Looks like OpenVPN is already installed What do you want to do? 1) Add a new user 2) Revoke an existing user 3) Remove OpenVPN 4) Exit Select an option [1-4]: 1 Tell me a name for the client certificate Please, use one word only, no special characters Client name: iphone7 This will generate a .ovpn file, which needs to be copied to your client machine (often times using the OpenVPN app). This process also generates a few other files found in /etc/openvpn/easy-rsa/pki/ , which make public key authentication possible; you only need to worry about the .ovpn file, though.","title":"Create a client config file (.ovpn)"},{"location":"guides/vpn/clients/#connect-a-client-using-the-ovpn-file","text":"The OpenVPN documentation has some decent guides on connecting desktop clients for Mac, Windows, and Linux , so we'll instead explain how to connect a mobile device, since that provides the most usefulness in today's world-- connecting to your ad-blocking VPN via a mobile device . We'll go through two examples: connect an iPhone using the OpenVPN Connect mobile app (see here for Android) connect a Linux machine","title":"Connect a client using the .ovpn file"},{"location":"guides/vpn/clients/#ios","text":"First make sure the OpenVPN connect app is installed on your phone or mobile device. Import the .ovpn file into iOS. There are several ways to do this, but be careful about transferring it over an insecure medium. Airdrop the file from another device Store the file in a cloud app and open it ion your device Message the file to yourself (not recommended) Email the file to yourself (not recommended) WARNING Anyone who gets his hands on this configuration/certificate file can obtain full access to your VPN. Make sure that you use only trusted paths for transferring the file (e.g. never send it via an un-encrypted channel, e.g. email or FTP). Best strategy is to use an USB thumb drive to avoid any network transport at all (when possible). Make sure to delete the certificate on the USB drive afterwards. NOTICE If one of your certificates has been compromised, remove it using option 2 when you run the installer and generate a new certificate. This will effectively lock out anyone who might have gotten access to the certificate. Once you get it on your device, you can open the file in the OpenVPN app. Click the green plus to add the profile to your phone. You can connect from within the app or you can connect from the Settings app once you grant it access to do so.","title":"iOS"},{"location":"guides/vpn/clients/#linux","text":"We'll demonstrate the procedure here for Ubuntu Linux (which trivially extends to Linux Mint, etc.) Install the necessary network-manager plugins sudo apt-get install network-manager-openvpn network-manager-openvpn-gnome sudo service network-manager restart Securely copy the necessary certificates from your OpenVPN server to your client (e.g. using sftp ). They are located in /etc/openvpn/easy-rsa/pki You will need: User Certificate: /etc/openvpn/easy-rsa/pki/issued/client.crt CA Certificate: /etc/openvpn/easy-rsa/pki/ca.crt Private Key: /etc/openvpn/easy-rsa/pki/private/client.key Private Key Password: Depending on your settings (might even be empty) TA Key: /etc/openvpn/ta.key Further details can be found in the screenshots provided below: Your whole network traffic will now securely be transferred to your Pi-hole.","title":"Linux"},{"location":"guides/vpn/clients/#windows","text":"You will have to install additional software. See https://openvpn.net/index.php/open-source/downloads.html","title":"Windows"},{"location":"guides/vpn/dual-VPN/","text":"Dual VPN Setup - Separate DNS and VPN Traffic In order to separate VPN traffic from DNS queries you will need to run two VPN servers. One server routes the normal user traffic and the second routes only DNS requests. This can be done with two OpenVPN configurations. Prerequisites and Configuration You should have an existing OpenVPN server configured and running. We are going to use the original configuration file located at /etc/openvpn/server.conf . First, copy the file: sudo cp /etc/openvpn/server.conf /etc/openvpn/server2.conf Next, exit the new copy of the configuration. We use the nano editor in this example, but any editor will work. Remember to edit under the root account via sudo . sudo nano /etc/openvpn/server2.conf We will need to change the port to one different from the original, so that it does not conflict with the first instance of OpenVPN. Assuming you used the default port configuration, you should have 1194 as the port. You need to change this to a different value, making sure the port is available - 1195 should be. Next, if needed, port forward the newly configured port from your router to your device. You will also need to assign a different class of IP addresses that will serve this connection only. Your server line should look like this: server 10.9.0.0 255.255.255.0 Make sure that the DNS requests go though the instance of OpenVPN: push dhcp-option DNS 10.9.0.1 One other setting that we need to change is to comment out the bypass-dhcp instruction so that it looks like: # push redirect-gateway def1 bypass-dhcp `. Commenting out this line ensures that no traffic is routed via the VPN server. Save the file and start the second instance of OpenVPN: systemctl start openvpn@server2.service If your distribution does not have systemctl you may use the command below to start an OpenVPN daemon with your second configuration: /usr/sbin/openvpn --daemon --writepid /var/run/openvpn/server2.pid --cd /etc/openvpn --config server2.conf --script-security 2 Finally, edit the existing .ovpn file used for the client connection. Update the port from the previous value to the port you used for the second instance of OpenVPN. Testing Before testing, make sure that: Port forwarding is configured for the second instance of OpenVPN. ps ax | grep openvpn shows two instances of OpenVPN running (with different configs). The modified ovpn file is loaded on the client. Note: when connected to your DNS only VPN connection you will not get a Pi-hole splash page when accessing a blocked domain directly. The page will not load or it may load with an error. This is because the web server traffic is not routed through the VPN. We did not create an iptables rule for masquerading, and the return packets (since they are not part of the same LAN subset as your VPN Client) are prevented.","title":"Optional: Full and DNS-only"},{"location":"guides/vpn/dual-VPN/#dual-vpn-setup-separate-dns-and-vpn-traffic","text":"In order to separate VPN traffic from DNS queries you will need to run two VPN servers. One server routes the normal user traffic and the second routes only DNS requests. This can be done with two OpenVPN configurations.","title":"Dual VPN Setup - Separate DNS and VPN Traffic"},{"location":"guides/vpn/dual-VPN/#prerequisites-and-configuration","text":"You should have an existing OpenVPN server configured and running. We are going to use the original configuration file located at /etc/openvpn/server.conf . First, copy the file: sudo cp /etc/openvpn/server.conf /etc/openvpn/server2.conf Next, exit the new copy of the configuration. We use the nano editor in this example, but any editor will work. Remember to edit under the root account via sudo . sudo nano /etc/openvpn/server2.conf We will need to change the port to one different from the original, so that it does not conflict with the first instance of OpenVPN. Assuming you used the default port configuration, you should have 1194 as the port. You need to change this to a different value, making sure the port is available - 1195 should be. Next, if needed, port forward the newly configured port from your router to your device. You will also need to assign a different class of IP addresses that will serve this connection only. Your server line should look like this: server 10.9.0.0 255.255.255.0 Make sure that the DNS requests go though the instance of OpenVPN: push dhcp-option DNS 10.9.0.1 One other setting that we need to change is to comment out the bypass-dhcp instruction so that it looks like: # push redirect-gateway def1 bypass-dhcp `. Commenting out this line ensures that no traffic is routed via the VPN server. Save the file and start the second instance of OpenVPN: systemctl start openvpn@server2.service If your distribution does not have systemctl you may use the command below to start an OpenVPN daemon with your second configuration: /usr/sbin/openvpn --daemon --writepid /var/run/openvpn/server2.pid --cd /etc/openvpn --config server2.conf --script-security 2 Finally, edit the existing .ovpn file used for the client connection. Update the port from the previous value to the port you used for the second instance of OpenVPN.","title":"Prerequisites and Configuration"},{"location":"guides/vpn/dual-VPN/#testing","text":"Before testing, make sure that: Port forwarding is configured for the second instance of OpenVPN. ps ax | grep openvpn shows two instances of OpenVPN running (with different configs). The modified ovpn file is loaded on the client. Note: when connected to your DNS only VPN connection you will not get a Pi-hole splash page when accessing a blocked domain directly. The page will not load or it may load with an error. This is because the web server traffic is not routed through the VPN. We did not create an iptables rule for masquerading, and the return packets (since they are not part of the same LAN subset as your VPN Client) are prevented.","title":"Testing"},{"location":"guides/vpn/dual-operation/","text":"Up until now, this wiki has been about a server set up on a cloud host, available on the public Internet. This section is aimed at a server setup in a private network like on a Raspberry Pi. So if blocking works using eth0 but stops working for tun0 , as described here , you may want to run this command pihole -a -i all , which should get the behaviour you want by opening dnsmasq up to listen on all ports. This is not recommended for cloud servers as they should not be listening on eth0 . If you want to set up your Pi-hole + OpenVPN such that you can use from both internal ((W)LAN) and external (VPN) networks, you have to apply some small changes. As additional benefit, you will be able to reach all devices in the internal network (e.g. computers, networking-aware printers, etc.) through the VPN. This setup assumes that your local network is in the range 192.168.2.0 (i.e. device addresses are in the range of 192.168.2.1 - 192.168.2.254). If this is not the case for you, you have to adjust the settings, accordingly, e.g. devices in 192.168.0.1 - 192.168.0.254 - route 192.168.0.0 devices in 192.168.123.1 - 192.168.123.254 - route 192.168.123.0 Edit your /etc/openvpn/server.conf : push route 192.168.2.0 255.255.255.0 push dhcp-option DNS 192.168.2.123 As you can see, we change the address of the DNS server to the local IP address of our Pi-hole (which is 192.168.2.123 in this example). Afterwards, we change the interface of Pi-hole to eth0 (your local network adapter instead of the VPN adapter tun0 ). This can conveniently be done by using pihole -r + Reconfigure . After a restart of the OpenVPN server, all clients should be able to see all devices within your (at home) local network. This is an example running on a distant server, which is connected through the VPN and can successfully communicate with all internal devices: me@client ~ $ ifconfig eth0 Link encap:Ethernet HWaddr e0:xx:xx:xx:xx:xx inet addr:134.x.x.x Bcast:134.x.x.x Mask:255.x.x.x inet6 addr: X:X:X:X::X/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:3623911 errors:0 dropped:0 overruns:0 frame:0 TX packets:2803670 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:1921375471 (1.9 GB) TX bytes:1227835028 (1.2 GB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:553426 errors:0 dropped:0 overruns:0 frame:0 TX packets:553426 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:113417383 (113.4 MB) TX bytes:113417383 (113.4 MB) tun0 Link encap:UNSPEC HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 inet addr:10.8.0.2 P-t-P:10.8.0.2 Mask:255.255.255.0 UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1500 Metric:1 RX packets:274676 errors:0 dropped:0 overruns:0 frame:0 TX packets:331178 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:100 RX bytes:43745313 (43.7 MB) TX bytes:43956250 (43.9 MB) me@client ~ $ ping 192.168.2.123 PING 192.168.2.123 (192.168.2.123) 56(84) bytes of data. 64 bytes from 192.168.2.123: icmp_seq=1 ttl=64 time=18.9 ms 64 bytes from 192.168.2.123: icmp_seq=2 ttl=64 time=18.9 ms 64 bytes from 192.168.2.123: icmp_seq=3 ttl=64 time=18.9 ms 64 bytes from 192.168.2.123: icmp_seq=4 ttl=64 time=18.7 ms 64 bytes from 192.168.2.123: icmp_seq=5 ttl=64 time=18.7 ms 64 bytes from 192.168.2.123: icmp_seq=6 ttl=64 time=19.0 ms ^C --- 192.168.2.123 ping statistics --- 6 packets transmitted, 6 received, 0% packet loss, time 5007ms rtt min/avg/max/mdev = 18.740/18.894/19.017/0.189 ms Important last step The undocumented pihole -a -i all command is simply what runs when you choose Listen on all interfaces, permit all origins (make sure your Pi-hole is firewalled) , which if you've read this far in the tutorial, you should understand that we don't want you to knowingly or unknowing set up an open resolver.","title":"Optional: Dual operation: LAN & VPN at the same time"},{"location":"guides/vpn/dual-operation/#important-last-step","text":"The undocumented pihole -a -i all command is simply what runs when you choose Listen on all interfaces, permit all origins (make sure your Pi-hole is firewalled) , which if you've read this far in the tutorial, you should understand that we don't want you to knowingly or unknowing set up an open resolver.","title":"Important last step"},{"location":"guides/vpn/dynDNS/","text":"If you operate your Pi-hole + OpenVPN at home, it is very likely that you are sitting behind a NAT / dynamically changing IP address. In this case, you should set up a dynamic DNS record, which allows you to reach your server. You can exchange the address that has been configured during the setup of OpenVPN like this: vim /etc/openvpn/client-common.txt Look for the remote line and adjust it accordingly (remove IP address, add host name), e.g. remote home.mydomain.de 1194 This change has to be repeated in each client config file ( *.conf ) that you have been created up till now. If you have set up a DDNS domain for your IP address, you will likely need to add a host-record to Pi-hole's settings. pihole -a hostrecord home.mydomain.de 192.168.1.10 If you don't do this, clients (like the Android OpenVPN client) will not able to connect to the VPN server when inside the internal network (while it will work from outside). Afterwards, the client will be able to connect to the VPN server both from inside and outside you local network.","title":"Optional: Dynamic DNS"},{"location":"guides/vpn/firewall/","text":"(optional) Secure the server with firewall rules ( iptables ) This step is recommended if you are running your server in the cloud, such as a droplet made on Digital Ocean . If this is the case, you need to secure the server for your safety as well as others to prevent aiding in DDoS attacks. In addition to the risk of being an open resolver, your Web interface is also open to the world increasing the risk. So you will want to prevent ports 53 and 80, respectively, from being accessible from the public Internet. It's recommended that you clear out your entire firewall so you have full control over it's setup. You have two options for setting up your firewall with your VPN. Option 1: Allow everything from within your VPN Enter this command, which will allow all traffic through the VPN tun0 interface. iptables -I INPUT -i tun0 -j ACCEPT Option 2: Explicitly allow what can be accessed within the VPN These commands will allow DNS and HTTP needed for name resolution (using Pi-hole as a resolver) and accessing the Web interface, respectively. iptables -A INPUT -i tun0 -p tcp --destination-port 53 -j ACCEPT iptables -A INPUT -i tun0 -p udp --destination-port 53 -j ACCEPT iptables -A INPUT -i tun0 -p tcp --destination-port 80 -j ACCEPT You will also want to enable SSH and VPN access from anywhere. iptables -A INPUT -p tcp --destination-port 22 -j ACCEPT iptables -A INPUT -p tcp --destination-port 1194 -j ACCEPT iptables -A INPUT -p udp --destination-port 1194 -j ACCEPT The next crucial setting is to explicitly allow TCP/IP to do \"three way handshakes\": iptables -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT Also, we want to allow any loopback traffic, i.e. the server is allowed to talk to itself without any limitations using 127.0.0.0/8: iptables -I INPUT -i lo -j ACCEPT Finally, reject access from anywhere else (i.e. if no rule has matched up to this point): iptables -P INPUT DROP Blocking HTTPS advertisement assets Since you're :head-desk: ing with iptables , you can also use this opportunity to block HTTPS advertisements to improve blocking ads that are loaded via HTTPS and also deal with QUIC. Why doesn't Pi-hole just use a certificate to prevent this? The answer is here . iptables -A INPUT -p udp --dport 80 -j REJECT --reject-with icmp-port-unreachable iptables -A INPUT -p tcp --dport 443 -j REJECT --reject-with tcp-reset iptables -A INPUT -p udp --dport 443 -j REJECT --reject-with icmp-port-unreachable Depending on the systems you have connecting, you may benefit from appending --reject-with tcp-reset to the command above. If you still get slow load times of HTTPS assets, the above may help. If you want to test how your Pi-hole behaves with blocking HTTP vs. HTTPS assets, use this page . IPv6 iptables If your server is reachable via IPv6, you'll need to run the same commands but using ip6tables : ip6tables -A INPUT -i tun0 -p tcp --destination-port 53 -j ACCEPT ip6tables -A INPUT -i tun0 -p udp --destination-port 53 -j ACCEPT ip6tables -A INPUT -i tun0 -p tcp --destination-port 80 -j ACCEPT ip6tables -A INPUT -p tcp --destination-port 22 -j ACCEPT ip6tables -A INPUT -p tcp --destination-port 1194 -j ACCEPT ip6tables -A INPUT -p udp --destination-port 1194 -j ACCEPT ip6tables -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT ip6tables -I INPUT -i lo -j ACCEPT ip6tables -A INPUT -p udp --dport 80 -j REJECT --reject-with icmp6-port-unreachable ip6tables -A INPUT -p tcp --dport 443 -j REJECT --reject-with tcp-reset ip6tables -A INPUT -p udp --dport 443 -j REJECT --reject-with icmp6-port-unreachable ip6tables -P INPUT DROP View the rules you just created iptables -L --line-numbers and they should look something like this: Chain INPUT (policy DROP) num target prot opt source destination 1 ACCEPT all -- anywhere anywhere 2 ACCEPT all -- anywhere anywhere state RELATED,ESTABLISHED 3 ACCEPT all -- anywhere anywhere 4 ACCEPT tcp -- anywhere anywhere tcp dpt:domain 5 ACCEPT udp -- anywhere anywhere udp dpt:domain 6 ACCEPT tcp -- anywhere anywhere tcp dpt:http 7 ACCEPT udp -- anywhere anywhere udp dpt:80 8 ACCEPT tcp -- anywhere anywhere tcp dpt:ssh 9 ACCEPT tcp -- anywhere anywhere tcp dpt:openvpn 10 ACCEPT udp -- anywhere anywhere udp dpt:openvpn 11 ACCEPT tcp -- 10.8.0.0/24 anywhere tcp dpt:domain 12 ACCEPT udp -- 10.8.0.0/24 anywhere udp dpt:domain 13 ACCEPT tcp -- 10.8.0.0/24 anywhere tcp dpt:http 14 ACCEPT udp -- 10.8.0.0/24 anywhere udp dpt:80 15 ACCEPT tcp -- 10.8.0.0/24 anywhere tcp dpt:domain 16 ACCEPT tcp -- 10.8.0.0/24 anywhere tcp dpt:http 17 ACCEPT udp -- 10.8.0.0/24 anywhere udp dpt:domain 18 ACCEPT udp -- 10.8.0.0/24 anywhere udp dpt:80 19 REJECT tcp -- anywhere anywhere tcp dpt:https reject-with icmp-port-unreachable Chain FORWARD (policy ACCEPT) num target prot opt source destination Chain OUTPUT (policy ACCEPT) num target prot opt source destination Similarly, ip6tables -L --line-numbers should look like this: Chain INPUT (policy DROP) num target prot opt source destination 1 ACCEPT all anywhere anywhere 2 ACCEPT all anywhere anywhere state RELATED,ESTABLISHED 3 ACCEPT tcp anywhere anywhere tcp dpt:domain 4 ACCEPT udp anywhere anywhere udp dpt:domain 5 ACCEPT tcp anywhere anywhere tcp dpt:http 6 ACCEPT udp anywhere anywhere udp dpt:80 7 ACCEPT tcp anywhere anywhere tcp dpt:ssh 8 ACCEPT tcp anywhere anywhere tcp dpt:openvpn 9 ACCEPT udp anywhere anywhere udp dpt:openvpn 10 REJECT tcp anywhere anywhere tcp dpt:https reject-with icmp6-port-unreachable Chain FORWARD (policy ACCEPT) num target prot opt source destination Chain OUTPUT (policy ACCEPT) num target prot opt source destination Verify the rules are working Connect to the VPN as a client and verify you can resolve DNS names as well as access the Pi-hole Web interface. These settings are stored in memory until you save them. If it's not working, you can restart your server to start from scratch. Alternatively, you could also go through and delete lines with iptables -D INPUT SOME LINE NUMBER Save your iptables If things look good, you may want to save your rules so you can revert to them if you ever make changes to the firewall. Save them with these commands: iptables-save /etc/pihole/rules.v4 ip6tables-save /etc/pihole/rules.v6 Similarly, you can restore these rules: iptables-restore /etc/pihole/rules.v4 ip6tables-restore /etc/pihole/rules.v6","title":"Firewall Configuration"},{"location":"guides/vpn/firewall/#optional-secure-the-server-with-firewall-rules-iptables","text":"This step is recommended if you are running your server in the cloud, such as a droplet made on Digital Ocean . If this is the case, you need to secure the server for your safety as well as others to prevent aiding in DDoS attacks. In addition to the risk of being an open resolver, your Web interface is also open to the world increasing the risk. So you will want to prevent ports 53 and 80, respectively, from being accessible from the public Internet. It's recommended that you clear out your entire firewall so you have full control over it's setup. You have two options for setting up your firewall with your VPN.","title":"(optional) Secure the server with firewall rules (iptables)"},{"location":"guides/vpn/firewall/#option-1-allow-everything-from-within-your-vpn","text":"Enter this command, which will allow all traffic through the VPN tun0 interface. iptables -I INPUT -i tun0 -j ACCEPT","title":"Option 1: Allow everything from within your VPN"},{"location":"guides/vpn/firewall/#option-2-explicitly-allow-what-can-be-accessed-within-the-vpn","text":"These commands will allow DNS and HTTP needed for name resolution (using Pi-hole as a resolver) and accessing the Web interface, respectively. iptables -A INPUT -i tun0 -p tcp --destination-port 53 -j ACCEPT iptables -A INPUT -i tun0 -p udp --destination-port 53 -j ACCEPT iptables -A INPUT -i tun0 -p tcp --destination-port 80 -j ACCEPT You will also want to enable SSH and VPN access from anywhere. iptables -A INPUT -p tcp --destination-port 22 -j ACCEPT iptables -A INPUT -p tcp --destination-port 1194 -j ACCEPT iptables -A INPUT -p udp --destination-port 1194 -j ACCEPT The next crucial setting is to explicitly allow TCP/IP to do \"three way handshakes\": iptables -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT Also, we want to allow any loopback traffic, i.e. the server is allowed to talk to itself without any limitations using 127.0.0.0/8: iptables -I INPUT -i lo -j ACCEPT Finally, reject access from anywhere else (i.e. if no rule has matched up to this point): iptables -P INPUT DROP","title":"Option 2: Explicitly allow what can be accessed within the VPN"},{"location":"guides/vpn/firewall/#blocking-https-advertisement-assets","text":"Since you're :head-desk: ing with iptables , you can also use this opportunity to block HTTPS advertisements to improve blocking ads that are loaded via HTTPS and also deal with QUIC. Why doesn't Pi-hole just use a certificate to prevent this? The answer is here . iptables -A INPUT -p udp --dport 80 -j REJECT --reject-with icmp-port-unreachable iptables -A INPUT -p tcp --dport 443 -j REJECT --reject-with tcp-reset iptables -A INPUT -p udp --dport 443 -j REJECT --reject-with icmp-port-unreachable Depending on the systems you have connecting, you may benefit from appending --reject-with tcp-reset to the command above. If you still get slow load times of HTTPS assets, the above may help. If you want to test how your Pi-hole behaves with blocking HTTP vs. HTTPS assets, use this page .","title":"Blocking HTTPS advertisement assets"},{"location":"guides/vpn/firewall/#ipv6-iptables","text":"If your server is reachable via IPv6, you'll need to run the same commands but using ip6tables : ip6tables -A INPUT -i tun0 -p tcp --destination-port 53 -j ACCEPT ip6tables -A INPUT -i tun0 -p udp --destination-port 53 -j ACCEPT ip6tables -A INPUT -i tun0 -p tcp --destination-port 80 -j ACCEPT ip6tables -A INPUT -p tcp --destination-port 22 -j ACCEPT ip6tables -A INPUT -p tcp --destination-port 1194 -j ACCEPT ip6tables -A INPUT -p udp --destination-port 1194 -j ACCEPT ip6tables -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT ip6tables -I INPUT -i lo -j ACCEPT ip6tables -A INPUT -p udp --dport 80 -j REJECT --reject-with icmp6-port-unreachable ip6tables -A INPUT -p tcp --dport 443 -j REJECT --reject-with tcp-reset ip6tables -A INPUT -p udp --dport 443 -j REJECT --reject-with icmp6-port-unreachable ip6tables -P INPUT DROP View the rules you just created iptables -L --line-numbers and they should look something like this: Chain INPUT (policy DROP) num target prot opt source destination 1 ACCEPT all -- anywhere anywhere 2 ACCEPT all -- anywhere anywhere state RELATED,ESTABLISHED 3 ACCEPT all -- anywhere anywhere 4 ACCEPT tcp -- anywhere anywhere tcp dpt:domain 5 ACCEPT udp -- anywhere anywhere udp dpt:domain 6 ACCEPT tcp -- anywhere anywhere tcp dpt:http 7 ACCEPT udp -- anywhere anywhere udp dpt:80 8 ACCEPT tcp -- anywhere anywhere tcp dpt:ssh 9 ACCEPT tcp -- anywhere anywhere tcp dpt:openvpn 10 ACCEPT udp -- anywhere anywhere udp dpt:openvpn 11 ACCEPT tcp -- 10.8.0.0/24 anywhere tcp dpt:domain 12 ACCEPT udp -- 10.8.0.0/24 anywhere udp dpt:domain 13 ACCEPT tcp -- 10.8.0.0/24 anywhere tcp dpt:http 14 ACCEPT udp -- 10.8.0.0/24 anywhere udp dpt:80 15 ACCEPT tcp -- 10.8.0.0/24 anywhere tcp dpt:domain 16 ACCEPT tcp -- 10.8.0.0/24 anywhere tcp dpt:http 17 ACCEPT udp -- 10.8.0.0/24 anywhere udp dpt:domain 18 ACCEPT udp -- 10.8.0.0/24 anywhere udp dpt:80 19 REJECT tcp -- anywhere anywhere tcp dpt:https reject-with icmp-port-unreachable Chain FORWARD (policy ACCEPT) num target prot opt source destination Chain OUTPUT (policy ACCEPT) num target prot opt source destination Similarly, ip6tables -L --line-numbers should look like this: Chain INPUT (policy DROP) num target prot opt source destination 1 ACCEPT all anywhere anywhere 2 ACCEPT all anywhere anywhere state RELATED,ESTABLISHED 3 ACCEPT tcp anywhere anywhere tcp dpt:domain 4 ACCEPT udp anywhere anywhere udp dpt:domain 5 ACCEPT tcp anywhere anywhere tcp dpt:http 6 ACCEPT udp anywhere anywhere udp dpt:80 7 ACCEPT tcp anywhere anywhere tcp dpt:ssh 8 ACCEPT tcp anywhere anywhere tcp dpt:openvpn 9 ACCEPT udp anywhere anywhere udp dpt:openvpn 10 REJECT tcp anywhere anywhere tcp dpt:https reject-with icmp6-port-unreachable Chain FORWARD (policy ACCEPT) num target prot opt source destination Chain OUTPUT (policy ACCEPT) num target prot opt source destination","title":"IPv6 iptables"},{"location":"guides/vpn/firewall/#verify-the-rules-are-working","text":"Connect to the VPN as a client and verify you can resolve DNS names as well as access the Pi-hole Web interface. These settings are stored in memory until you save them. If it's not working, you can restart your server to start from scratch. Alternatively, you could also go through and delete lines with iptables -D INPUT SOME LINE NUMBER","title":"Verify the rules are working"},{"location":"guides/vpn/firewall/#save-your-iptables","text":"If things look good, you may want to save your rules so you can revert to them if you ever make changes to the firewall. Save them with these commands: iptables-save /etc/pihole/rules.v4 ip6tables-save /etc/pihole/rules.v6 Similarly, you can restore these rules:","title":"Save your iptables"},{"location":"guides/vpn/firewall/#iptables-restore-etcpiholerulesv4-ip6tables-restore-etcpiholerulesv6","text":"","title":"iptables-restore &lt; /etc/pihole/rules.v4"},{"location":"guides/vpn/installation/","text":"Install an operating system Once you have your preferred OS up and running. You may already have a server set up on your network, or you may prefer to make a Digital Ocean droplet. In either case, you'll use the quick OpenVPN \"road warrior\" installer. The cloud-hosted server option is convenient if you don't want to host the hardware at home, but you'll need to take additional steps to secure the server as it's available on the public Internet. Failure to do so is not only irresponsible, but you also put yourself and others at risk . Install OpenVPN + Pi-hole A note about security For security purposes, it is recommended that the CA machine should be separate from the machine running OpenVPN. If you lose control of your CA private key, you can no longer trust any certificates from this CA. Anyone with access to this CA private key can sign new certificates without your knowledge, which then can connect to your OpenVPN server without needing to modify anything on the VPN server. Place your CA files on a storage which can be offline as much as possible, only to be activated when you need to get a new certificate for a client or server. This is less convenient, so many users will simply decide to install Pi-hole and OpenVPN on a single machine, which is what this guide will walkthrough. Install the OpenVPN server First, download the OpenVPN installer; make it executable, and then run it: wget https://git.io/vpn -O openvpn-install.sh chmod 755 openvpn-install.sh ./openvpn-install.sh Enter your server's IP address and accept all the defaults, unless you require special needs: Welcome to this quick OpenVPN road warrior installer I need to ask you a few questions before starting the setup You can leave the default options and just press enter if you are ok with them First I need to know the IPv4 address of the network interface you want OpenVPN listening to. IP address: 10.8.0.1 Which protocol do you want for OpenVPN connections? 1) UDP (recommended) 2) TCP Protocol [1-2]: 1 What port do you want OpenVPN listening to? Port: 1194 Which DNS do you want to use with the VPN? 1) Current system resolvers 2) Google 3) OpenDNS 4) NTT 5) Hurricane Electric 6) Verisign DNS [1-6]: 1 Finally, tell me your name for the client certificate Please, use one word only, no special characters Client name: pihole Okay, that was all I needed. We are ready to setup your OpenVPN server now Press any key to continue... Let the installer run... Finished! Your client configuration is available at /root/pihole.ovpn If you want to add more clients, you simply need to run this script again! Install Pi-hole Next, install Pi-hole and choose tun0 as the interface and 10.8.0.1/24 as the IP address. You can accept the rest of the defaults, or configure Pi-hole to your liking. The interface selection is the most important step; if you don't choose tun0 (at least to begin with), it will not work properly. curl -sSL https://install.pi-hole.net | bash","title":"Installation"},{"location":"guides/vpn/installation/#install-an-operating-system","text":"Once you have your preferred OS up and running. You may already have a server set up on your network, or you may prefer to make a Digital Ocean droplet. In either case, you'll use the quick OpenVPN \"road warrior\" installer. The cloud-hosted server option is convenient if you don't want to host the hardware at home, but you'll need to take additional steps to secure the server as it's available on the public Internet. Failure to do so is not only irresponsible, but you also put yourself and others at risk .","title":"Install an operating system"},{"location":"guides/vpn/installation/#install-openvpn-pi-hole","text":"","title":"Install OpenVPN + Pi-hole"},{"location":"guides/vpn/installation/#a-note-about-security","text":"For security purposes, it is recommended that the CA machine should be separate from the machine running OpenVPN. If you lose control of your CA private key, you can no longer trust any certificates from this CA. Anyone with access to this CA private key can sign new certificates without your knowledge, which then can connect to your OpenVPN server without needing to modify anything on the VPN server. Place your CA files on a storage which can be offline as much as possible, only to be activated when you need to get a new certificate for a client or server. This is less convenient, so many users will simply decide to install Pi-hole and OpenVPN on a single machine, which is what this guide will walkthrough.","title":"A note about security"},{"location":"guides/vpn/installation/#install-the-openvpn-server","text":"First, download the OpenVPN installer; make it executable, and then run it: wget https://git.io/vpn -O openvpn-install.sh chmod 755 openvpn-install.sh ./openvpn-install.sh Enter your server's IP address and accept all the defaults, unless you require special needs: Welcome to this quick OpenVPN road warrior installer I need to ask you a few questions before starting the setup You can leave the default options and just press enter if you are ok with them First I need to know the IPv4 address of the network interface you want OpenVPN listening to. IP address: 10.8.0.1 Which protocol do you want for OpenVPN connections? 1) UDP (recommended) 2) TCP Protocol [1-2]: 1 What port do you want OpenVPN listening to? Port: 1194 Which DNS do you want to use with the VPN? 1) Current system resolvers 2) Google 3) OpenDNS 4) NTT 5) Hurricane Electric 6) Verisign DNS [1-6]: 1 Finally, tell me your name for the client certificate Please, use one word only, no special characters Client name: pihole Okay, that was all I needed. We are ready to setup your OpenVPN server now Press any key to continue... Let the installer run... Finished! Your client configuration is available at /root/pihole.ovpn If you want to add more clients, you simply need to run this script again!","title":"Install the OpenVPN server"},{"location":"guides/vpn/installation/#install-pi-hole","text":"Next, install Pi-hole and choose tun0 as the interface and 10.8.0.1/24 as the IP address. You can accept the rest of the defaults, or configure Pi-hole to your liking. The interface selection is the most important step; if you don't choose tun0 (at least to begin with), it will not work properly. curl -sSL https://install.pi-hole.net | bash","title":"Install Pi-hole"},{"location":"guides/vpn/only-dns-via-vpn/","text":"Optional: Only route DNS via VPN With this setup, you will force connected clients to use only the DNS provided by the VPN connection, i.e. the Pi-hole. Do this only if you don't want to tunnel all traffic from the client through the VPN, but only its DNS queries. Edit your /etc/openvpn/server.conf and remove (comment out) the following line: # push redirect-gateway def1 bypass-dhcp Using a client config file This works pretty much out of the box with common client.ovpn files, like this provided one: client.ovpn Remember to replace the locations of your keys and the address/host name of your server. Using the Network Manager When using the Network Manager, you will have to do some additional setting on the client side of things: Alternative 1: Disable Network Manager's internal DNS server Edit /etc/NetworkManager/NetworkManager.conf : # dns=dnsmasq and restart the Network Manager: sudo restart network-manager When connecting your DNS server will now be properly picked up and used by your client. Alternative 2: Set DNS server address of your Pi-hole manually on the main interface You can also set the address of the DNS server manually (use the device which actually connects to the internet, e.g. eth0 ): After doing either alternative, you should see: pi.hole has address W.X.Y.Z (outside address of your VPN server) pi.hole has IPv6 address A:B:C:D:E:F (outside address of your VPN server) The web interface of your Pi-hole will be visible at http://pi.hole/admin/ (even with the recommended firewall configuration mentioned on another subpage) Troubleshooting If your new DNS server configuration has not been activated (try restarting the interface / system) you will see host pi.hole Host pi.hole not found: 3(NXDOMAIN) If you are not connected to your VPN network you will see host pi.hole ;; connection timed out; no servers could be reached","title":"Optional: Only route DNS via VPN"},{"location":"guides/vpn/only-dns-via-vpn/#optional-only-route-dns-via-vpn","text":"With this setup, you will force connected clients to use only the DNS provided by the VPN connection, i.e. the Pi-hole. Do this only if you don't want to tunnel all traffic from the client through the VPN, but only its DNS queries. Edit your /etc/openvpn/server.conf and remove (comment out) the following line: # push redirect-gateway def1 bypass-dhcp","title":"Optional: Only route DNS via VPN"},{"location":"guides/vpn/only-dns-via-vpn/#using-a-client-config-file","text":"This works pretty much out of the box with common client.ovpn files, like this provided one: client.ovpn Remember to replace the locations of your keys and the address/host name of your server.","title":"Using a client config file"},{"location":"guides/vpn/only-dns-via-vpn/#using-the-network-manager","text":"When using the Network Manager, you will have to do some additional setting on the client side of things:","title":"Using the Network Manager"},{"location":"guides/vpn/only-dns-via-vpn/#alternative-1-disable-network-managers-internal-dns-server","text":"Edit /etc/NetworkManager/NetworkManager.conf : # dns=dnsmasq and restart the Network Manager: sudo restart network-manager When connecting your DNS server will now be properly picked up and used by your client.","title":"Alternative 1: Disable Network Manager's internal DNS server"},{"location":"guides/vpn/only-dns-via-vpn/#alternative-2-set-dns-server-address-of-your-pi-hole-manually-on-the-main-interface","text":"You can also set the address of the DNS server manually (use the device which actually connects to the internet, e.g. eth0 ): After doing either alternative, you should see: pi.hole has address W.X.Y.Z (outside address of your VPN server) pi.hole has IPv6 address A:B:C:D:E:F (outside address of your VPN server) The web interface of your Pi-hole will be visible at http://pi.hole/admin/ (even with the recommended firewall configuration mentioned on another subpage)","title":"Alternative 2: Set DNS server address of your Pi-hole manually on the main interface"},{"location":"guides/vpn/only-dns-via-vpn/#troubleshooting","text":"If your new DNS server configuration has not been activated (try restarting the interface / system) you will see host pi.hole Host pi.hole not found: 3(NXDOMAIN) If you are not connected to your VPN network you will see host pi.hole ;; connection timed out; no servers could be reached","title":"Troubleshooting"},{"location":"guides/vpn/overview/","text":"This tutorial is tailored for setting up OpenVPN on a cloud-hosted virtual server (such as Digital Ocean ). If you wish to have this working on your home network, you will need to tailor Pi-hole to listen on eth0 (or similar), which we explain in this section of the tutorial . High-level Overview Using a VPN is a responsible, respectful, and safe way to access your Pi-hole's capabilities remotely. Setting up a DNS server has become a simple task with Pi-hole's automated installer, which has resulted in many people knowingly--or unknowingly--creating an open resolver, which aids in DNS Amplification Attacks. We do not encourage open resolvers but there are always people wanting access to their ad-blocking capabilities outside of their home network, whether it's on their cellular network or on an unsecured wireless network. This article aims to provide a step-by-step walk-through on setting up a server running Pi-hole and OpenVPN so you can connect to your Pi-hole's DNS from anywhere. This guide should work for a private server installed on your private network, but it will also work for cloud servers, such as those created on Digital Ocean . This tutorial walks you through the installation of Pi-hole combined with an VPN server for secure access from remote clients . Via this VPN, you can: use the DNS server and full filtering capabilities of your Pi-hole from everywhere around the globe access your admin interface remotely encrypt your Internet traffic If you don't want a full-tunnel, we provide a wiki of how to set up your server to exclusively route DNS traffic, but nothing else via the VPN . On another optional page, we describe how to set up Pi-hole + VPN in such a way that it is usable both locally (no VPN) and from remote (through VPN) , while preserving full functionality. In the end, you will have access to a VPN that uses Pi-hole for DNS and tunnels some or all of your network traffic This manual is partially based on this HowTo on Discourse .","title":"Overview"},{"location":"guides/vpn/overview/#high-level-overview","text":"Using a VPN is a responsible, respectful, and safe way to access your Pi-hole's capabilities remotely. Setting up a DNS server has become a simple task with Pi-hole's automated installer, which has resulted in many people knowingly--or unknowingly--creating an open resolver, which aids in DNS Amplification Attacks. We do not encourage open resolvers but there are always people wanting access to their ad-blocking capabilities outside of their home network, whether it's on their cellular network or on an unsecured wireless network. This article aims to provide a step-by-step walk-through on setting up a server running Pi-hole and OpenVPN so you can connect to your Pi-hole's DNS from anywhere. This guide should work for a private server installed on your private network, but it will also work for cloud servers, such as those created on Digital Ocean . This tutorial walks you through the installation of Pi-hole combined with an VPN server for secure access from remote clients . Via this VPN, you can: use the DNS server and full filtering capabilities of your Pi-hole from everywhere around the globe access your admin interface remotely encrypt your Internet traffic If you don't want a full-tunnel, we provide a wiki of how to set up your server to exclusively route DNS traffic, but nothing else via the VPN . On another optional page, we describe how to set up Pi-hole + VPN in such a way that it is usable both locally (no VPN) and from remote (through VPN) , while preserving full functionality. In the end, you will have access to a VPN that uses Pi-hole for DNS and tunnels some or all of your network traffic This manual is partially based on this HowTo on Discourse .","title":"High-level Overview"},{"location":"guides/vpn/setup-openvpn-server/","text":"Change OpenVPN's resolvers First, find the IP of your tun0 interface: On Jessie ifconfig tun0 | grep inet addr On Stretch ip a Edit the OpenVPN config file: vim /etc/openvpn/server.conf Set this line to use your Pi-hole's IP address, which you determined from the ifconfig command and comment out or remove the other line (if it exists): push dhcp-option DNS 10.8.0.1 #push dhcp-option DNS 8.8.8.8 This push directive is setting a DHCP option , which tells client's connecting to the VPN that they should use Pi-hole as their primary DNS server. It's suggested to have Pi-hole be the only resolver as it defines the upstream servers. Setting a non-Pi-hole resolver here may have adverse effects on ad blocking but it can provide failover connectivity in the case of Pi-hole not working if that is something you are concerned about. Restart OpenVPN to apply the changes Depending on your operating system, one of these commands should work to restart the service. systemctl restart openvpn service openvpn restart Create a client config file ( .ovpn ) Now that the server is configured, you'll want to connect some clients so you can make use of your Pi-hole wherever you are. Doing so requires the use of a certificate. You generate these and the resulting .ovpn file by running the installer and choosing 1) Add a new user for each client that will connect to the VPN. You can repeat this process for as many clients as you need. In this example, we'll \"Add a new user\" by naming the .ovpn file the same as the client's hostname but you may want to adopt your own naming strategy. Run the OpenVPN installer again ./openvpn-install.sh Choose 1) Add a new user and enter a client name Looks like OpenVPN is already installed What do you want to do? 1) Add a new user 2) Revoke an existing user 3) Remove OpenVPN 4) Exit Select an option [1-4]: 1 Tell me a name for the client certificate Please, use one word only, no special characters Client name: iphone7 This will generate a .ovpn file, which needs to be copied to your client machine (often times using the OpenVPN app). This process also generates a few other files found in /etc/openvpn/easy-rsa/pki/ , which make public key authentication possible; you only need to worry about the .ovpn file, though.","title":"Setup OpenVPN Server"},{"location":"guides/vpn/setup-openvpn-server/#change-openvpns-resolvers","text":"First, find the IP of your tun0 interface: On Jessie ifconfig tun0 | grep inet addr On Stretch ip a Edit the OpenVPN config file: vim /etc/openvpn/server.conf Set this line to use your Pi-hole's IP address, which you determined from the ifconfig command and comment out or remove the other line (if it exists): push dhcp-option DNS 10.8.0.1 #push dhcp-option DNS 8.8.8.8 This push directive is setting a DHCP option , which tells client's connecting to the VPN that they should use Pi-hole as their primary DNS server. It's suggested to have Pi-hole be the only resolver as it defines the upstream servers. Setting a non-Pi-hole resolver here may have adverse effects on ad blocking but it can provide failover connectivity in the case of Pi-hole not working if that is something you are concerned about.","title":"Change OpenVPN's resolvers"},{"location":"guides/vpn/setup-openvpn-server/#restart-openvpn-to-apply-the-changes","text":"Depending on your operating system, one of these commands should work to restart the service. systemctl restart openvpn service openvpn restart","title":"Restart OpenVPN to apply the changes"},{"location":"guides/vpn/setup-openvpn-server/#create-a-client-config-file-ovpn","text":"Now that the server is configured, you'll want to connect some clients so you can make use of your Pi-hole wherever you are. Doing so requires the use of a certificate. You generate these and the resulting .ovpn file by running the installer and choosing 1) Add a new user for each client that will connect to the VPN. You can repeat this process for as many clients as you need. In this example, we'll \"Add a new user\" by naming the .ovpn file the same as the client's hostname but you may want to adopt your own naming strategy. Run the OpenVPN installer again ./openvpn-install.sh Choose 1) Add a new user and enter a client name Looks like OpenVPN is already installed What do you want to do? 1) Add a new user 2) Revoke an existing user 3) Remove OpenVPN 4) Exit Select an option [1-4]: 1 Tell me a name for the client certificate Please, use one word only, no special characters Client name: iphone7 This will generate a .ovpn file, which needs to be copied to your client machine (often times using the OpenVPN app). This process also generates a few other files found in /etc/openvpn/easy-rsa/pki/ , which make public key authentication possible; you only need to worry about the .ovpn file, though.","title":"Create a client config file (.ovpn)"},{"location":"main/basic-install/","text":"One-Step Automated Install Those who want to get started quickly and conveniently, may install Pi-hole using the following command: curl -sSL https://install.pi-hole.net | bash Info Piping to bash is a controversial topic , as it prevents you from reading code that is about to run on your system. If you would prefer to review the code before installation, we provide these alternative installation methods. Alternative 1: Clone our repository and run git clone --depth 1 https://github.com/pi-hole/pi-hole.git Pi-hole cd Pi-hole/automated install/ sudo bash basic-install.sh Alternative 2: Manually download the installer and run wget -O basic-install.sh https://install.pi-hole.net sudo bash basic-install.sh","title":"Installation"},{"location":"main/basic-install/#one-step-automated-install","text":"Those who want to get started quickly and conveniently, may install Pi-hole using the following command: curl -sSL https://install.pi-hole.net | bash Info Piping to bash is a controversial topic , as it prevents you from reading code that is about to run on your system. If you would prefer to review the code before installation, we provide these alternative installation methods.","title":"One-Step Automated Install"},{"location":"main/basic-install/#alternative-1-clone-our-repository-and-run","text":"git clone --depth 1 https://github.com/pi-hole/pi-hole.git Pi-hole cd Pi-hole/automated install/ sudo bash basic-install.sh","title":"Alternative 1: Clone our repository and run"},{"location":"main/basic-install/#alternative-2-manually-download-the-installer-and-run","text":"wget -O basic-install.sh https://install.pi-hole.net sudo bash basic-install.sh","title":"Alternative 2: Manually download the installer and run"},{"location":"main/post-install/","text":"Making your network take advantage of Pi-hole Once the installer has been run, you will need to configure your router to have DHCP clients use Pi-hole as their DNS server which ensures that all devices connecting to your network will have content blocked without any further intervention. If your router does not support setting the DNS server, you can use Pi-hole's built in DHCP server ; just be sure to disable DHCP on your router first (if it has that feature available). As a last resort, you can always manually set each device to use Pi-hole as their DNS server.","title":"Post-Install"},{"location":"main/post-install/#making-your-network-take-advantage-of-pi-hole","text":"Once the installer has been run, you will need to configure your router to have DHCP clients use Pi-hole as their DNS server which ensures that all devices connecting to your network will have content blocked without any further intervention. If your router does not support setting the DNS server, you can use Pi-hole's built in DHCP server ; just be sure to disable DHCP on your router first (if it has that feature available). As a last resort, you can always manually set each device to use Pi-hole as their DNS server.","title":"Making your network take advantage of Pi-hole"},{"location":"main/prerequesites/","text":"Hardware Pi-hole is very lightweight, and does not require much processing power ~52MB of free space 512MB RAM Despite the name, you are not limited to running Pi-hole on a Raspberry Pi. Any hardware that runs one of the supported operating systems will do! Supported Operating Systems The following operating systems are officially supported: Raspbian: Jessie / Stretch Ubuntu: 16.04 / 16.10 Fedora: 27 / 28 Debian: 8 / 9 CentOS: 7 (not ARM) IP Addressing Pi-hole needs a static IP address to properly function (a DHCP reservation is just fine). Users may run into issues because we currently install dhcpcd5 , which may conflict with other running network managers such as dhclient , dhcpcd , networkmanager , and systemd-networkd . As part of our install process, we append some lines to /etc/dhcpcd.conf in order to statically assign an IP address , so take note of this prior to installing. Please be aware of this fact because it may cause confusion . This is not the ideal situation for us to be in, but since a significant portion of our users are running Pi-hole on Raspbian; and because Pi-hole's roots began with the Raspberry Pi, it's a problem that is difficult problem to get away from . Due to the complexity of different ways of setting an IP address across different systems, it's a slow process and we need help . If you're willing to contribute, please let us know. Ports Service Port Protocol Notes dnsmasq 53 ( DNS ) TCP / UDP If you happen to have another DNS server running, such as BIND, you will need to turn it off in order for Pi-hole to respond to DNS queries. dnsmasq 67 ( DHCP ) IPv4 UDP The DHCP server is an optional feature that requires additional ports. dnsmasq 547 ( DHCPv6 ) IPv6 UDP The DHCP server is an optional feature that requires additional ports. lighttpd 80 ( HTTP ) TCP If you have another Web server already running, such as Apache, Pi-hole's Web server will not work. You can either disable the other Web server or change the port on which lighttpd listens, which allows you keep both Web servers running. pihole- FTL 4711 TCP FTL is our API engine and uses port 4711 on the localhost interface. This port should not be accessible from any other interface. Info The use of lighttpd on port 80 is optional if you decide not to install the Web dashboard during installation. The use of dnsmasq on ports 67 or 547 is optional, but required if you use the DHCP functions of Pi-hole. Firewalls Below are some examples of firewall rules that will need to be set on your Pi-hole server in order to use the functions available. These are only shown as guides, the actual commands used will be found with your distributions documentation. IPTables IPTables uses two sets of tables. One set is for IPv4 chains, and the second is for IPv6 chains. If only IPv4 blocking is used for the Pi-hole installation, only apply the rules for IP4Tables. Full Stack ( IPv4 and IPv6 ) require both sets of rules to be applied. Note: These examples insert the rules at the front of the chain. Please see your distributions documentation to see the exact proper command to use. IPTables ( IPv4 ) iptables -I INPUT 1 -p tcp -m tcp --dport 80 -j ACCEPT iptables -I INPUT 1 -p tcp -m tcp --dport 53 -j ACCEPT iptables -I INPUT 1 -p udp -m udp --dport 53 -j ACCEPT iptables -I INPUT 1 -p udp -m tcp --dport 67 -j ACCEPT iptables -I INPUT 1 -p udp -m udp --dport 67 -j ACCEPT iptables -I INPUT 1 -p tcp -m tcp --dport 4711 -i lo -j ACCEPT IP6Tables ( IPv6 ) ip6tables -I INPUT -p udp -m udp --sport 546 :547 --dport 546 :547 -j ACCEPT FirewallD Using the --permanent argument will ensure the firewall rules persist reboots. If only IPv4 blocking is used for the Pi-hole installation, the dhcpv6 service can be removed the the commands below. Create a new zone for the local interface ( lo ) for the pihole- FTL ports to ensure the API is only accessible locally. Finally --reload to have the new firewall configuration take effect immediately. firewall-cmd --permanent --add-service = http --add-service = dns --add-service = dhcp --add-service = dhcpv6 firewall-cmd --permanent --new-zone = ftl firewall-cmd --permanent --zone = ftl --add-interface = lo firewall-cmd --permanent --zone = ftl --add-port = 4711 /tcp firewall-cmd --reload","title":"Prerequisites"},{"location":"main/prerequesites/#hardware","text":"Pi-hole is very lightweight, and does not require much processing power ~52MB of free space 512MB RAM Despite the name, you are not limited to running Pi-hole on a Raspberry Pi. Any hardware that runs one of the supported operating systems will do!","title":"Hardware"},{"location":"main/prerequesites/#supported-operating-systems","text":"The following operating systems are officially supported: Raspbian: Jessie / Stretch Ubuntu: 16.04 / 16.10 Fedora: 27 / 28 Debian: 8 / 9 CentOS: 7 (not ARM)","title":"Supported Operating Systems"},{"location":"main/prerequesites/#ip-addressing","text":"Pi-hole needs a static IP address to properly function (a DHCP reservation is just fine). Users may run into issues because we currently install dhcpcd5 , which may conflict with other running network managers such as dhclient , dhcpcd , networkmanager , and systemd-networkd . As part of our install process, we append some lines to /etc/dhcpcd.conf in order to statically assign an IP address , so take note of this prior to installing. Please be aware of this fact because it may cause confusion . This is not the ideal situation for us to be in, but since a significant portion of our users are running Pi-hole on Raspbian; and because Pi-hole's roots began with the Raspberry Pi, it's a problem that is difficult problem to get away from . Due to the complexity of different ways of setting an IP address across different systems, it's a slow process and we need help . If you're willing to contribute, please let us know.","title":"IP Addressing"},{"location":"main/prerequesites/#ports","text":"Service Port Protocol Notes dnsmasq 53 ( DNS ) TCP / UDP If you happen to have another DNS server running, such as BIND, you will need to turn it off in order for Pi-hole to respond to DNS queries. dnsmasq 67 ( DHCP ) IPv4 UDP The DHCP server is an optional feature that requires additional ports. dnsmasq 547 ( DHCPv6 ) IPv6 UDP The DHCP server is an optional feature that requires additional ports. lighttpd 80 ( HTTP ) TCP If you have another Web server already running, such as Apache, Pi-hole's Web server will not work. You can either disable the other Web server or change the port on which lighttpd listens, which allows you keep both Web servers running. pihole- FTL 4711 TCP FTL is our API engine and uses port 4711 on the localhost interface. This port should not be accessible from any other interface. Info The use of lighttpd on port 80 is optional if you decide not to install the Web dashboard during installation. The use of dnsmasq on ports 67 or 547 is optional, but required if you use the DHCP functions of Pi-hole.","title":"Ports"},{"location":"main/prerequesites/#firewalls","text":"Below are some examples of firewall rules that will need to be set on your Pi-hole server in order to use the functions available. These are only shown as guides, the actual commands used will be found with your distributions documentation.","title":"Firewalls"},{"location":"main/prerequesites/#iptables","text":"IPTables uses two sets of tables. One set is for IPv4 chains, and the second is for IPv6 chains. If only IPv4 blocking is used for the Pi-hole installation, only apply the rules for IP4Tables. Full Stack ( IPv4 and IPv6 ) require both sets of rules to be applied. Note: These examples insert the rules at the front of the chain. Please see your distributions documentation to see the exact proper command to use. IPTables ( IPv4 ) iptables -I INPUT 1 -p tcp -m tcp --dport 80 -j ACCEPT iptables -I INPUT 1 -p tcp -m tcp --dport 53 -j ACCEPT iptables -I INPUT 1 -p udp -m udp --dport 53 -j ACCEPT iptables -I INPUT 1 -p udp -m tcp --dport 67 -j ACCEPT iptables -I INPUT 1 -p udp -m udp --dport 67 -j ACCEPT iptables -I INPUT 1 -p tcp -m tcp --dport 4711 -i lo -j ACCEPT IP6Tables ( IPv6 ) ip6tables -I INPUT -p udp -m udp --sport 546 :547 --dport 546 :547 -j ACCEPT","title":"IPTables"},{"location":"main/prerequesites/#firewalld","text":"Using the --permanent argument will ensure the firewall rules persist reboots. If only IPv4 blocking is used for the Pi-hole installation, the dhcpv6 service can be removed the the commands below. Create a new zone for the local interface ( lo ) for the pihole- FTL ports to ensure the API is only accessible locally. Finally --reload to have the new firewall configuration take effect immediately. firewall-cmd --permanent --add-service = http --add-service = dns --add-service = dhcp --add-service = dhcpv6 firewall-cmd --permanent --new-zone = ftl firewall-cmd --permanent --zone = ftl --add-interface = lo firewall-cmd --permanent --zone = ftl --add-port = 4711 /tcp firewall-cmd --reload","title":"FirewallD"},{"location":"main/update/","text":"Updating is as simple as running the following command: pihole -up Common issues with updating: [Placeholder for solutions to issues]","title":"Updating"},{"location":"main/update/#common-issues-with-updating","text":"[Placeholder for solutions to issues]","title":"Common issues with updating:"}]}